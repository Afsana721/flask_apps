<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AptiCraft: The Design Nexus</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght[300;400;700]&display=swap"
        rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.umd.js"></script>

    <script>
        // Customizing the Tailwind configuration for the AptiCraft Circuit/Neon Green theme
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'background': '#151515',
                        'surface': '#262626',
                        'primary-text': '#E5E7EB',
                        'accent-glow': '#00FF7F',   // Electric Mint/Neon Green
                        'title-color': '#FFFFFF',
                        'trace': '#007F40',
                        'electron': '#33FF99',      // Bright current flow
                        'source-red': '#FF4500',    // Red for positive side of source
                        'source-blue': '#1E90FF',   // Blue for negative side of source
                        'inductor-coil': '#FFD700', // Gold/Yellow for Inductor field
                        'ic-chip': '#8A2BE2',       // Blue Violet for IC
                        'mem-color': '#FF8C00',     // Dark Orange for Memory
                        'cpu-color': '#DC143C',     // Crimson for CPU
                        'io-color': '#00BFFF',      // Deep Sky Blue for I/O
                        'von-neumann': '#33FF99',   // Neon green for combined bus
                        'harvard-inst': '#1E90FF',  // Deep blue for instruction bus (Particles)
                        'harvard-data': '#FF4500',  // Orange-red for data bus (Particles)
                        'diagram-frame': '#E0E0E0', // Light gray for the frame
                        'diagram-bus-line': '#A0A0A0', // Gray for bus lines
                        'diagram-box': '#FFFFFF',   // White for component boxes
                        'diagram-text': '#000000',  // Black for text inside boxes
                        'data-particle': '#FF8C00', // Orange for data particles
                        'instruction-particle': '#1E90FF', // Blue for instruction particles
                        'arch-background': '#1A1A1A', // New dark background for arch diagram
                    },
                    fontFamily: {
                        'title-serif': ['Cinzel', 'serif'],
                        'sans': ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body {
            background-color: #151515;
            font-family: 'Inter', sans-serif;
            color: #E5E7EB;
            overflow-x: hidden;
        }

        /* Hero Text Styles: Large, Centered, High Contrast */
        .hero-title {
            font-size: clamp(2rem, 8vw, 4rem);
            line-height: 1.1;
            font-weight: 700;
            letter-spacing: -0.05em;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        /* Application Button Styling */
        .app-button {
            transition: transform 0.2s ease, box-shadow 0.3s ease;
            filter: grayscale(100%);
        }

        .app-button:hover {
            filter: grayscale(0%);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 255, 127, 0.5);
        }

        /* Simulation Interface Panel - Container for the circuit editor */
        .simulation-interface {
            height: 60vh;
            min-height: 400px;
            background-color: #000000;
            border: 1px solid #333333;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
            touch-action: none;
        }

        /* Canvas specific styling */
        #circuitCanvas {
            cursor: grab;
            display: block;
            background-color: #050505;
            border-radius: 4px;
        }

        /* NEW: Style for the Architecture Canvas (2D) */
        #architectureCanvas {
            display: block;
            width: 100%;
            height: 400px;
            /* Fixed height for the 2D view */
            background-color: #1A1A1A;
            /* Dark background as requested */
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            margin: 0 auto;
        }

        /* Styling for the draggable components in the palette */
        .palette-item {
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .palette-item:hover {
            background-color: rgba(0, 255, 127, 0.1);
            color: #00FF7F;
        }

        .palette-item.disabled {
            color: #444;
            cursor: not-allowed;
        }

        /* --- Custom Styles for Attiny85 SVG Animation --- */
        #attinyWrap svg {
            width: 100%;
            height: 500px;
            background: radial-gradient(circle at center, #0a0f1f 0%, #000 100%)
        }

        .chip {
            fill: #0f172a;
            stroke: #60a5fa;
            stroke-width: 2
        }

        .pin {
            fill: #1e293b;
            stroke: #93c5fd;
            stroke-width: 1.5
        }

        .text {
            fill: #e2e8f0;
            font-weight: 700;
            font-size: 14px
        }

        .wire {
            fill: none;
            stroke: #3b82f6;
            stroke-width: 4;
            stroke-dasharray: 8 14;
            animation: flow 1.2s linear infinite
        }

        .wire-red {
            stroke: #ef4444;
            stroke-width: 4;
            stroke-dasharray: 8 14;
            animation: flow 1.2s linear infinite
        }

        .led {
            fill: #0f172a;
            stroke: #22d3ee;
            stroke-width: 2
        }

        .led-glow {
            fill: url(#glow);
            opacity: 0.2
        }

        .led-on {
            animation: blink 1.8s ease-in-out infinite
        }

        .button {
            fill: #d1d5db;
            stroke: #9ca3af;
            stroke-width: 2;
            animation: press 3s ease-in-out infinite
        }

        @keyframes flow {
            to {
                stroke-dashoffset: -24
            }
        }

        @keyframes blink {

            0%,
            70%,
            100% {
                opacity: .2
            }

            50% {
                opacity: 1
            }
        }

        @keyframes press {

            0%,
            80%,
            100% {
                transform: translateY(0)
            }

            40% {
                transform: translateY(3px)
            }
        }

        .marquee {
            position: relative;
            overflow: hidden;
            white-space: nowrap
        }

        .marquee .track {
            display: inline-block;
            padding-left: 100%;
            will-change: transform;
            animation: marqueeX 12s linear infinite
        }

        @keyframes marqueeX {
            from {
                transform: translateX(0)
            }

            to {
                transform: translateX(-100%)
            }
        }

        /* --- End Attiny85 Styles --- */

        /* --- Custom Footer Styles --- */
        @keyframes color-shift {
            0% {
                border-color: #00FF7F;
                box-shadow: 0 0 10px rgba(0, 255, 127, 0.5);
            }

            50% {
                border-color: #33FFFF;
                box-shadow: 0 0 15px rgba(51, 255, 255, 0.7);
            }

            100% {
                border-color: #00FF7F;
                box-shadow: 0 0 10px rgba(0, 255, 127, 0.5);
            }
        }

        .animated-footer {
            animation: color-shift 4s ease-in-out infinite;
        }

        /* --- End Custom Footer Styles --- */
    </style>
</head>

<body class="bg-background min-h-screen">
    <header class="w-full bg-background border-b border-surface sticky top-0 z-20">
        <div class="max-w-7xl mx-auto flex justify-between items-center p-4 md:p-6">
            <h1 class="text-xl font-bold text-accent-glow font-title-serif tracking-widest">

                <span class="text-3xl text-cyan-200">
                    <img src="./static/aptiCraft.png" alt="log" class="inline bg-gray-300 w-10 h-10 rounded-full mr-6">
                    AptiCraft</span>  Every Circuit
            </h1>
            <input type="text" placeholder="Search..."
                class="hidden md:block px-4 py-2 bg-surface text-primary-text rounded-md border border-gray-600 w-64 focus:border-accent-glow focus:outline-none">

            <nav class="flex space-x-4 md:space-x-8 text-sm font-medium uppercase text-primary-text">
                <a href="/" class="hover:text-accent-glow transition duration-200">Home</a>
                <a href="#" class="hover:text-accent-glow transition duration-200">Others</a>
                <a href="#" class="hover:text-accent-glow transition duration-200">Info</a>
            </nav>
        </div>
    </header>
    <main class="max-w-7xl mx-auto p-4 md:p-12 space-y-56">
        <section class="text-center pt-8 md:pt-16">
            <div
                class="max-w-3xl mx-auto mb-16 p-4 bg-surface/50 rounded-lg border-l-4 border-accent-glow/50 text-sm text-primary-text/80 leading-relaxed">
                <p>
                    <strong class="text-accent-glow">PROGRAM UPDATE:</strong> EveryCircuit is an online and mobile app
                    to design,
                    simulate, share, and discover electronic circuits. <a href="https://everycircuit.com/"
                        class="text-accent-glow hover:underline text-sm"> Every Circuit</a>.
                </p>
            </div>
            <!-- ===== EC Stats Strip (drop-in snippet) ===== -->
            <section id="ec-stats" class="ec-section">
                <div class="ec-row relative overflow-hidden">

                    <!-- Card 1: Circuits -->
                    <button class="ec-card ec-left" type="button" onclick="onClickStatsCircuits()">
                        <div
                            class="ec-card-inner transition-transform duration-300 ease-out hover:scale-[1.04] hover:-translate-y-0.5 hover:shadow-[0_28px_90px_rgba(34,255,136,.25),0_18px_55px_rgba(255,155,61,.28)]">
                            <div><span class="ec-gradient ec-strong">2.9&nbsp;M</span> circuits<br>made in EveryCircuit
                            </div>
                        </div>
                    </button>

                    <div class="ec-sep" aria-hidden="true"></div>

                    <!-- Card 2: Easy animated -->
                    <button class="ec-card" type="button" onclick="onClickStatsAnimated()">
                        <div
                            class="ec-card-inner transition-transform duration-300 ease-out hover:scale-[1.04] hover:-translate-y-0.5 hover:shadow-[0_28px_90px_rgba(34,255,136,.25),0_18px_55px_rgba(255,155,61,.28)]">
                            <div><span class="ec-gradient ec-strong">Easy</span> animated<br>interactive simulation
                            </div>
                        </div>
                    </button>

                    <div class="ec-sep" aria-hidden="true"></div>

                    <!-- Card 3: Platforms -->
                    <div class="ec-card">
                        <div
                            class="ec-card-inner transition-transform duration-300 ease-out hover:scale-[1.04] hover:-translate-y-0.5 hover:shadow-[0_28px_90px_rgba(34,255,136,.25),0_18px_55px_rgba(255,155,61,.28)]">
                            <div>
                                <span class="ec-gradient ec-strong">3</span> platforms<br>
                                <a class="ec-link" target="_blank" href="/app">Online</a>,&thinsp;
                                <a class="ec-link" target="_blank"
                                    href="https://play.google.com/store/apps/details?id=com.everycircuit.free">Android</a>,&thinsp;
                                <a class="ec-link" target="_blank"
                                    href="https://apps.apple.com/us/app/everycircuit/id797157761">iOS</a>
                            </div>
                        </div>
                    </div>
                    <div class="ec-sep" aria-hidden="true"></div>
                    <!-- Card 4: Class license -->
                    <button class="ec-card ec-right" type="button" onclick="onClickClassLicense()">
                        <div
                            class="ec-card-inner transition-transform duration-300 ease-out hover:scale-[1.04] hover:-translate-y-0.5 hover:shadow-[0_28px_90px_rgba(34,255,136,.25),0_18px_55px_rgba(255,155,61,.28)]">
                            <div><span class="ec-gradient ec-strong">Class</span><br>license for educators</div>
                        </div>
                    </button>

                </div>
            </section>
            <style>
                /* --- Scoped styles for #ec-stats --- */
                :root {
                    --ec-bg: #151515;
                    /* page background reference */
                    --ec-card: #151515;
                    /* card background */
                    --ec-border: rgba(255, 255, 255, .08);
                    --ec-border-strong: rgba(255, 255, 255, .16);
                    --ec-text: #d8deff;
                    /* light text */
                    --ec-muted: #9aa3c7;
                    /* secondary text */
                    --ec-accent-orange: #ff9b3d;
                    /* warm accent */
                    --ec-accent-amber: #f59e0b;
                    /* secondary warm */
                    --ec-accent-green: #22ff88;
                    /* glow green */
                }

                #ec-stats.ec-section {
                    padding: 24px 0
                }

                #ec-stats .ec-row {
                    position: relative;
                    display: flex;
                    align-items: stretch;
                    justify-content: center;
                    gap: 0;
                    max-width: 1100px;
                    margin: 0 auto;
                    background: linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .02));
                    border: 1px solid var(--ec-border);
                    border-radius: 14px;
                    box-shadow: 0 30px 90px rgba(0, 0, 0, .55), 0 20px 60px rgba(0, 0, 0, .35) inset, 0 0 0 1px rgba(34, 255, 136, .08);
                }

                /* subtle orange/indigo perimeter glow */
                #ec-stats .ec-row::after {
                    content: "";
                    position: absolute;
                    inset: -2px;
                    border-radius: 16px;
                    pointer-events: none;
                    z-index: 0;
                    background: conic-gradient(from 220deg at 50% 50%, rgba(106, 128, 255, .25), rgba(58, 214, 255, .18), rgba(255, 255, 255, 0) 22%, rgba(255, 255, 255, 0) 55%, rgba(255, 155, 61, .25) 75%, rgba(245, 158, 11, .22) 90%, rgba(106, 128, 255, .25) 1turn);
                    filter: blur(14px);
                    opacity: .6;
                }

                #ec-stats .ec-card {
                    background: transparent;
                    border: 0;
                    padding: 0;
                    margin: 0;
                    cursor: pointer;
                    flex: 1 1 0;
                }

                #ec-stats .ec-card:where(:focus-visible) {
                    outline: 2px solid #6ea8ff;
                    outline-offset: 2px;
                    border-radius: 12px
                }


                #ec-stats .ec-card-inner {
                    height: 100%;
                    padding: 22px 28px;
                    color: var(--ec-text);
                    background: var(--ec-card);
                    border-top: 1px solid var(--ec-border-strong);
                    border-bottom: 1px solid var(--ec-border-strong);
                    position: relative;
                    overflow: hidden;
                }

                /* warm corner sparkle */
                #ec-stats .ec-card-inner::before {
                    content: "";
                    position: absolute;
                    right: -14%;
                    top: -14%;
                    width: 180px;
                    height: 180px;
                    border-radius: 50%;
                    background: radial-gradient(closest-side, rgba(247, 69, 38, 0.35), rgba(255, 155, 61, .08) 60%, transparent 70%);
                    filter: blur(16px);
                    opacity: .0;
                    transition: opacity .3s ease;
                }

                #ec-stats .ec-card:hover .ec-card-inner::before {
                    opacity: .9
                }

                #ec-stats .ec-left .ec-card-inner {
                    border-radius: 12px 0 0 12px
                }

                #ec-stats .ec-right .ec-card-inner {
                    border-radius: 0 12px 12px 0
                }

                #ec-stats .ec-sep {
                    width: 1px;
                    background: linear-gradient(180deg, transparent, var(--ec-border-strong), transparent)
                }

                /* luminous backlight */
                #ec-stats .ec-row::before {
                    content: "";
                    position: absolute;
                    inset: -40% -20% -20% -20%;
                    background:
                        radial-gradient(60% 50% at 50% -10%, rgba(80, 120, 255, .25), rgba(58, 214, 255, .12) 35%, transparent 70%),
                        radial-gradient(40% 30% at 80% 120%, rgba(182, 3, 107, 0.12), transparent 60%),
                        radial-gradient(55% 35% at 50% 120%, rgba(5, 114, 56, 0.18), transparent 60%);
                    filter: blur(44px);
                    opacity: .7;
                    pointer-events: none;
                    z-index: 0;
                    animation: ec-breathe 6s ease-in-out infinite;
                }

                #ec-stats .ec-card,
                #ec-stats .ec-sep {
                    position: relative;
                    z-index: 1
                }

                @keyframes ec-breathe {

                    0%,
                    100% {
                        opacity: .55;
                        transform: translateY(0)
                    }

                    50% {
                        opacity: .85;
                        transform: translateY(6px)
                    }
                }

                #ec-stats .ec-gradient {
                    background: linear-gradient(90deg, #3ad6ff, #6f8dff 40%, #9a6dff 62%, var(--ec-accent-orange) 85%, var(--ec-accent-green) 100%);
                    -webkit-background-clip: text;
                    background-clip: text;
                    color: transparent
                }

                #ec-stats .ec-strong {
                    font-weight: 800
                }

                #ec-stats .ec-link {
                    color: #9ec7ff;
                    text-decoration: none;
                    border-bottom: 1px dotted rgba(158, 199, 255, .5);
                    transition: color .2s ease, border-color .2s ease
                }

                /* Typography */
                #ec-stats .ec-card-inner div {
                    font: 600 18px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", sans-serif
                }

                #ec-stats .ec-card-inner div br {
                    line-height: 1
                }

                /* Responsive: stack on small screens */
                @media (max-width:900px) {
                    #ec-stats .ec-row {
                        flex-direction: column
                    }

                    #ec-stats .ec-sep {
                        height: 1px;
                        width: auto
                    }

                    #ec-stats .ec-left .ec-card-inner {
                        border-radius: 12px 12px 0 0
                    }

                    #ec-stats .ec-right .ec-card-inner {
                        border-radius: 0 0 12px 12px
                    }
                }
            </style>

            <script>
                // Optional click handlers (replace with your real functions)
                function onClickStatsCircuits() { console.log('Circuits clicked'); }
                function onClickStatsAnimated() { console.log('Animated clicked'); }
                function onClickClassLicense() { console.log('Class license clicked'); }
            </script>
            <!-- ===== /EC Stats Strip ===== -->
        </section>
        <section class="pb-8">
            <div class="simulation-interface mx-auto max-w-6xl">
                <div class="flex justify-between items-center mb-2 p-4">
                    <span class="text-xs text-accent-glow font-mono uppercase">EveryCircuit v5.2 Console</span>
                    <div class="flex space-x-2">
                        <div class="w-3 h-3 bg-red-600 rounded-full"></div>
                        <div class="w-3 h-3 bg-yellow-500 rounded-full"></div>
                        <div class="w-3 h-3 bg-green-500 rounded-full"></div>
                    </div>
                </div>
                <div class="h-6 bg-surface border-b border-gray-700 flex items-center px-2 space-x-4 text-xs">
                    <span class="text-primary-text/70">FILE</span>
                    <span class="text-primary-text/70">EDIT</span>
                    <span class="text-accent-glow">SIMULATE</span>
                    <span class="text-primary-text/70">ANALYZE</span>
                </div>
                <div class="flex h-[80%] pt-2">
                    <div id="component-palette"
                        class="w-1/6 bg-surface p-2 rounded-lg text-xs text-primary-text/70 overflow-y-auto">
                        <p class="font-bold mb-2 text-accent-glow uppercase tracking-wider">Palette</p>
                        <ul class="space-y-1">
                            <li class="palette-item" data-type="resistor">Resistor (R)</li>
                            <li class="palette-item" data-type="capacitor">Capacitor (C)</li>
                            <li class="palette-item" data-type="source">DC Source (V)</li>
                            <li class="palette-item" data-type="inductor">Inductor (L)</li>
                            <li class="palette-item disabled" data-type="ic">IC Chips</li>
                        </ul>
                        <p class="font-bold mt-4 mb-2 text-accent-glow uppercase tracking-wider">Info</p>
                        <p class="text-[10px] text-primary-text/60">
                            Drag components to move them. Electron flow animation indicates current direction.
                        </p>
                    </div>
                    <div class="flex-1 bg-black p-2 relative">
                        <canvas id="circuitCanvas" class="w-full h-full"></canvas>
                    </div>
                </div>
            </div>
        </section>
        <!--system related text-->
        {% raw %}
        <!-- ===== System Intro (drop-in, place above system animation) ===== -->
        <section id="system-intro" class="ec-section">
            <div class="si-wrap relative overflow-hidden">
                <header class="si-head">
                    <h2 class="si-title text-accent-glow">System Behind the Screen</h2>
                    <p class="si-sub text-[#00A550]">Low‑level engine that catches your input, schedules work, moves
                        data, and drives hardware.</p>
                </header>
                <div class="si-grid">
                    <article
                        class="si-card transition-transform duration-300 ease-out hover:scale-[1.03] hover:-translate-y-0.5 hover:shadow-[0_28px_90px_rgba(34,255,136,.25),0_18px_55px_rgba(255,155,61,.28)]">
                        <h3 class="si-h3"><span class="ec-gradient ec-strong font-weight text-[#3FFF00]">What System
                                does</span></h3>
                        <p>A computer system takes input, processes it according to instructions, stores the data, and
                            produces an output. It consists of physical hardware components
                            like the CPU and memory, and software components like the operating system that manage the
                            hardware and
                            run applications to perform specific tasks.</p>
                        <a href="https://www.geeksforgeeks.org/computer-science-fundamentals/basics-of-computer-and-its-operations/"
                            target="_blank" class="font-weight text-shadow text-accent-glow"><u>more info.</u></a>
                    </article>
                    <article
                        class="si-card transition-transform duration-300 ease-out hover:scale-[1.03] hover:-translate-y-0.5 hover:shadow-[0_28px_90px_rgba(34,255,136,.25),0_18px_55px_rgba(255,155,61,.28)]">
                        <h3 class="si-h3"><span class="ec-gradient ec-strong font-weight text-[#3FFF00]">How System
                                works</span></h3>
                        <div class="pipeline" aria-hidden="false">
                            <div class="step">
                                <div class="dot">Input</div>
                            </div>
                            <div class="connector">
                                <div class="bus">
                                    <div class="byte"></div>
                                </div>
                            </div>
                            <div class="step">
                                <div class="dot">Fetch</div>
                            </div>
                            <div class="connector small">
                                <div class="bus">
                                    <div class="byte delay"></div>
                                </div>
                            </div>
                            <div class="step">
                                <div class="dot">Decode</div>
                            </div>
                            <div class="connector small">
                                <div class="bus">
                                    <div class="byte delay2"></div>
                                </div>
                            </div>
                            <div class="step">
                                <div class="dot">Execute</div>
                            </div>
                            <div class="connector">
                                <div class="bus">
                                    <div class="byte delay3"></div>
                                </div>
                            </div>
                            <div class="step">
                                <div class="dot">Write</div>
                            </div>
                        </div>
                        <p class="si-vis-caption">Visual: bytes (small glowing dots) travel along buses between pipeline
                            stages.</p>
                        <a href="https://homepage.cs.uri.edu/faculty/wolfe/book/Readings/Reading04.htm" target="_blank"
                            class="font-weight text-shadow text-accent-glow"><u>more info.</u></a>
                    </article>
                    <article
                        class="si-card transition-transform duration-300 ease-out hover:scale-[1.03] hover:-translate-y-0.5 hover:shadow-[0_28px_90px_rgba(34,255,136,.25),0_18px_55px_rgba(255,155,61,.28)]">
                        <h3 class="si-h3"><span class="ec-gradient ec-strong font-weight text-[#3FFF00]">Why System
                                matters</span></h3>
                        <p>Computer systems are the most important due to their ability to increase efficiency, enhance
                            communication, and manage vast amounts of information.</p>
                        <a href="https://gbs.edu.mt/blog/understanding-the-fundamentals-of-computer-systems/"
                            target="_blank" class="font-weight text-shadow text-accent-glow"><u>more info.</u></a>
                    </article>
                </div>
            </div>
        </section>
        <!-- ===== /System Intro ===== -->

        <style>
            /* System extra section style Scoped styles for #system-intro — follows existing palette */
            #system-intro .si-wrap {
                max-width: 1100px;
                margin: 0 auto;
                padding: 32px;
                border: 1px solid var(--ec-border);
                border-radius: 14px;
                background: linear-gradient(180deg, rgba(255, 255, 255, .05), rgba(255, 255, 255, .02));
                box-shadow: 0 25px 80px rgba(0, 0, 0, .45), 0 20px 60px rgba(0, 0, 0, .35) inset, 0 0 0 1px rgba(34, 255, 136, .08)
            }

            #system-intro .si-wrap::before {
                content: "";
                position: absolute;
                inset: -40% -20% -20% -20%;
                background: radial-gradient(50% 40% at 15% -10%, rgba(34, 255, 136, .18), transparent 60%), radial-gradient(40% 30% at 90% 120%, rgba(255, 155, 61, .12), transparent 60%);
                filter: blur(44px);
                opacity: .7;
                pointer-events: none;
                z-index: 0;
                animation: ec-breathe 6s ease-in-out infinite
            }

            #system-intro .si-head {
                position: relative;
                z-index: 1;
                margin-bottom: 18px
            }

            #system-intro .si-title {
                margin: 0 0 6px;
                font: 800 26px/1.2 system-ui, -apple-system, Segoe UI, Inter, Roboto, Arial, sans-serif;
                color: var(--ec-text)
            }

            #system-intro .si-sub {
                margin: 0;
                color: var(--ec-muted);
                font: 500 15px/1.5 system-ui, -apple-system, Segoe UI, Inter, Roboto, Arial, sans-serif
            }

            #system-intro .si-grid {
                position: relative;
                z-index: 1;
                display: grid;
                grid-template-columns: repeat(3, minmax(0, 1fr));
                gap: 14px
            }

            #system-intro .si-card {
                background: var(--ec-card);
                border: 1px solid var(--ec-border-strong);
                border-radius: 12px;
                padding: 18px;
                color: var(--ec-text)
            }

            #system-intro .si-h3 {
                margin: 0 0 8px;
                font: 700 16px/1.3 system-ui, -apple-system, Segoe UI, Inter, Roboto, Arial, sans-serif
            }

            @media (max-width:900px) {
                #system-intro .si-grid {
                    grid-template-columns: 1fr
                }
            }
        </style>
        {% endraw %}

        <!--End of system related text-->


        <section class="mb-16 max-w-6xl mx-auto">
            <div class="p-6 bg-surface rounded-lg shadow-xl border border-gray-700">
                <h3
                    class="text-xl md:text-2xl font-bold font-title-serif text-accent-glow mb-4 uppercase tracking-wider border-b border-gray-700 pb-2">
                    SYSTEM AND CIRCUIT FUNDAMENTALS
                </h3>
                <h4 class="text-lg font-bold text-primary-text mt-6 mb-2">High-Performance Processor: Data Flow
                    Animation</h4>
                <div class="relative w-full overflow-hidden mb-4">
                    <canvas id="architectureCanvas" class="border border-diagram-frame"></canvas>
                    <div
                        class="absolute bottom-2 left-2 right-2 text-xs text-center p-1 bg-black/50 text-white rounded">
                        Binary data streams into the central processor in real-time.
                    </div>
                </div>


                <p class="text-sm text-primary-text/90 leading-relaxed">
                    A **circuit** is a closed loop that allows electrical energy (in the form of electrons) to flow
                    from a power source, through components that perform a function, and back to the source.
                    **Hardware** refers to the physical components like chips, wires, and the Central
                    Processing Unit (**CPU**).
                </p>
                <p class="text-sm text-primary-text/90 leading-relaxed mt-4">
                    This hardware operates using **binary logic**, communicating in **bits** where a high electrical
                    signal is **1** and a low signal is **0** . Tiny electronic switches called
                    **transistors** are arranged into logic gates (AND, OR, NOT) to perform millions of binary
                    calculations per second, which is the foundation of all digital computation.
                </p>

                <h4 class="text-lg font-bold text-primary-text mt-6 mb-2">The Role of the Operating System (OS)</h4>
                <p class="text-sm text-primary-text/90 leading-relaxed">
                    While circuits handle the raw logic, the **Operating System (OS)** acts as the critical bridge
                    between the hardware and the applications you use. It is a collection of software that manages the
                    computer's resources—including the CPU, memory, and input/output devices—by allocating them
                    efficiently to various running programs.
                </p>
                <ul class="list-disc list-inside space-y-1 text-sm text-primary-text/80 mt-3 ml-4">
                    <li>**Process Management:** The OS manages multiple programs and tasks simultaneously, ensuring they
                        run smoothly without interfering with one another.</li>
                    <li>**Memory Management:** It controls how much primary memory (RAM) and auxiliary storage is
                        assigned to each process, moving data between them as needed.</li>
                    <li>**File Management:** The OS organizes and secures files, controlling directories, file naming,
                        and user access permissions.</li>
                </ul>
                <div class="mt-6">
                    <a href="https://www.ibm.com/think/topics/operating-systems" target="_blank"
                        class="inline-block px-4 py-2 bg-accent-glow text-surface font-bold rounded-md text-sm hover:bg-opacity-90 transition duration-300 shadow-md">
                        Read More on Operating Systems &rarr;
                    </a>
                </div>
            </div>
        </section>

        <section class="mb-16 max-w-6xl mx-auto">
            <div class="p-6 bg-surface rounded-lg shadow-xl border border-gray-700">
                <h3
                    class="text-xl md:text-2xl font-bold font-title-serif text-accent-glow mb-4 uppercase tracking-wider border-b border-gray-700 pb-2">
                    FROM CIRCUITRY TO CODE: THE LOGIC CHAIN
                </h3>
                <p class="text-sm text-primary-text/90 leading-relaxed">
                    At its core, all computer programming, from high-level languages like Python to assembly code, is
                    translated back into the simple electrical states of a circuit. This translation process is built
                    upon fundamental digital logic:
                </p>

                <h4 class="text-lg font-bold text-primary-text mt-6 mb-2">The Binary Bridge (Logic Gates)</h4>
                <p class="text-sm text-primary-text/90 leading-relaxed">
                    Computer hardware only understands two states: ON (high voltage, representing a **1**) and OFF (low
                    voltage, representing a **0**). Tiny physical circuits called **Logic Gates** (such as AND, OR, and
                    NOT) combine these binary inputs to produce a single binary output. These gates are the foundational
                    "vocabulary" of the computer's language.
                </p>

                <h4 class="text-lg font-bold text-primary-text mt-6 mb-2">Machine Language and High-Level Abstraction
                </h4>
                <p class="text-sm text-primary-text/90 leading-relaxed">
                    The simplest language understood by the CPU is **Machine Language**, which consists of binary
                    instructions (streams of 1s and 0s) that directly command the hardware's internal registers and
                    memory. Because writing in binary is impractical for humans, **Assembly Language** was created as a
                    symbolic representation (e.g., "ADD," "MOV") of machine code. Higher-level languages (like C++,
                    Java, or JavaScript) then further abstract this process, using compilers or interpreters to
                    translate human-readable syntax into the machine-level instructions the circuits can execute.
                </p>

                <div class="mt-6">
                    <a href="http://www.electricalfun.com/workbenchfun/multilabs_basic_programming.htm" target="_blank"
                        class="inline-block px-4 py-2 bg-accent-glow text-surface font-bold rounded-md text-sm hover:bg-opacity-90 transition duration-300 shadow-md">
                        Read More on Basic Programming &rarr;
                    </a>
                </div>
            </div>
        </section>

        <!-- ===== MICROCONTROLLER LOGIC • INTERRUPT SIMULATION (drop‑in section) ===== -->
        <section id="mc-interrupts" class="mx-auto my-16 max-w-6xl">
        <style>
            /* Scoped to #mc-interrupts to avoid leaks */
            #mc-interrupts{--smoke:#0d0f14;--panel:#1a1f29;--ink:#e8ecff;--muted:#9aa7c7;--neon:#00ff88;--cyan:#00cccc;--amber:#ff9a00}
            #mc-interrupts{background:radial-gradient(900px 320px at 30% 0, rgba(0,204,204,.05), transparent 60%),
                        radial-gradient(800px 280px at 80% -10%, rgba(255,154,0,.05), transparent 60%),
                        var(--smoke);border:1px solid rgba(255,255,255,.08);border-radius:14px;box-shadow:0 20px 60px rgba(0,0,0,.45)}
            #mc-interrupts .wrap{padding:28px}
            #mc-interrupts .title{margin:0 0 8px;font:800 22px/1.15 system-ui,-apple-system,Segoe UI,Inter,Roboto,Arial,sans-serif;letter-spacing:.3px}
            #mc-interrupts .title span{color:var(--neon);text-shadow:0 0 10px rgba(0,255,136,.45)}
            #mc-interrupts .sub{margin:0 0 18px;color:var(--muted)}
            #mc-interrupts .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:16px}
            #mc-interrupts .card{background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.015));border:1px solid rgba(255,255,255,.07);border-radius:12px;padding:14px}
            #mc-interrupts h3{margin:0 0 8px;font:700 14px/1.3 system-ui;color:var(--ink)}
            #mc-interrupts p, #mc-interrupts li{color:var(--muted);font:600 12px/1.5 system-ui;margin:0}
            #mc-interrupts ul{margin:0;padding-left:18px}
            #mc-interrupts .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(0,255,136,.12);color:var(--neon);font:800 11px/1 system-ui;letter-spacing:.4px}
            #mc-interrupts canvas{width:100%;height:auto;display:block;background:radial-gradient(700px 240px at 50% 0, rgba(0,204,204,.05), transparent 60%), var(--panel);border:1px solid #243045;border-radius:10px}
            #mc-interrupts .legend{margin-top:6px;font:600 11px/1.2 system-ui;color:var(--muted)}
            #mc-interrupts .dot{display:inline-block;width:8px;height:8px;border-radius:50%;margin:0 6px 0 10px}
            #mc-interrupts .c1{background:var(--neon)} .c2{background:var(--cyan)} .c3{background:var(--amber)}
        </style>

        <div class="wrap border border-accent-glow/50">
            <h2 class="title"><span>MICROCONTROLLER LOGIC:</span> INTERRUPT SIMULATION</h2>
            <p class="sub">How an MCU stops normal code, saves context, and services higher‑priority events — then returns exactly where it left off.</p>

            <div class="grid">
            <!-- Left: concise explainer -->
            <article class="card">
                <h3><span class="badge">How it works</span></h3>
                <ul>
                <li><b>Pending</b>: hardware lines (IRQ1/2/3) pulse when peripherals need attention.</li>
                <li><b>Arbitrate</b>: a priority encoder chooses the highest active IRQ.</li>
                <li><b>Context push</b>: CPU auto‑saves PC/flags to the stack.</li>
                <li><b>Vector jump</b>: it branches to that ISR address (vector table).</li>
                <li><b>Service</b>: ISR clears the source, maybe queues data.</li>
                <li><b>Return</b>: POP context; resume main loop like nothing happened.</li>
                </ul>
            </article>

            <!-- Right: tiny animation -->
            <article class="card">
                <h3>Live timing diagram</h3>
                <canvas id="irqSim" width="560" height="170"></canvas>
                <div class="legend"><span class="dot c1"></span>IRQ1  <span class="dot c2"></span>IRQ2  <span class="dot c3"></span>IRQ3  ·  <b>CPU</b>: green=RUN, amber=ISR  ·  <b>STACK</b>: bars = push/pop</div>
            </article>
            </div>
        </div>

        <script>
        (function(){
            const cvs=document.getElementById('irqSim'); if(!cvs) return; const ctx=cvs.getContext('2d');
            const DPR=window.devicePixelRatio||1; cvs.width*=DPR; cvs.height*=DPR; ctx.scale(DPR,DPR);
            const W=cvs.width/DPR,H=cvs.height/DPR, row=28, top=18;
            const lanes=[{y:top+row*0,col:'#00ff88'},{y:top+row*1,col:'#00cccc'},{y:top+row*2,col:'#ff9a00'}];
            let t=0, cpuISR=0, stack=0, seed=1;
            function rnd(){seed=(seed*1664525+1013904223)|0; return (seed>>>0)/4294967296}
            const pulses=[[],[],[]];
            function addPulse(i){const w=30+Math.floor(rnd()*40); pulses[i].push({x:W+10,w});}
            for(let i=0;i<3;i++) for(let k=0;k<3;k++) addPulse(i);

            function step(dt){t+=dt; const speed=60; // px/s
            // scroll pulses
            for(let i=0;i<3;i++){
                for(const p of pulses[i]) p.x-=dt*speed;
                while(pulses[i].length && pulses[i][0].x<-80) pulses[i].shift();
                if(rnd()<0.02) addPulse(i);
            }
            // IRQ arbitration: if any pulse crosses center window, enter ISR
            const center=120; let active=-1; // higher index lower priority
            for(let i=0;i<3;i++){const hit=pulses[i].some(p=>p.x<center && p.x+p.w>center); if(hit){active=i; break}}
            if(active!==-1){cpuISR=1; stack=Math.min(6, stack+10*dt);} else {cpuISR=Math.max(0,cpuISR-3*dt); stack=Math.max(0, stack-12*dt);}  
            }

            function draw(){ctx.clearRect(0,0,W,H);
            // grid
            ctx.strokeStyle='rgba(255,255,255,.06)'; ctx.lineWidth=1; for(let y=top-12;y<H-20;y+=row){ctx.beginPath();ctx.moveTo(10,y);ctx.lineTo(W-10,y);ctx.stroke()}
            // lanes
            lanes.forEach((ln,i)=>{ctx.fillStyle='rgba(255,255,255,.6)'; ctx.font='11px system-ui'; ctx.fillText('IRQ'+(i+1), 10, ln.y-6);
                for(const p of pulses[i]){ctx.fillStyle=ln.col; ctx.shadowColor=ln.col; ctx.shadowBlur=10; ctx.fillRect(p.x, ln.y-10, p.w, 20);}
                ctx.shadowBlur=0;
            });
            // CPU state bar
            ctx.fillStyle='rgba(255,255,255,.8)'; ctx.fillText('CPU', 10, top+row*3+20);
            ctx.fillStyle= cpuISR>0.5? 'rgba(255,154,0,1)' : 'rgba(0,255,136,1)';
            ctx.shadowColor= ctx.fillStyle; ctx.shadowBlur=16; ctx.fillRect(60, top+row*3+8, 120, 14); ctx.shadowBlur=0;
            // stack bars
            ctx.fillStyle='rgba(255,255,255,.8)'; ctx.fillText('STACK', 10, top+row*4+20);
            ctx.strokeStyle='rgba(148,163,184,.6)'; ctx.strokeRect(60, top+row*4+8, 140, 14);
            ctx.fillStyle='rgba(0,204,204,.9)'; ctx.fillRect(60, top+row*4+8, stack*20, 14);
            // center service window
            ctx.strokeStyle='rgba(255,255,255,.18)'; ctx.setLineDash([5,6]); ctx.beginPath(); ctx.moveTo(120,10); ctx.lineTo(120,H-10); ctx.stroke(); ctx.setLineDash([]);
            }

            let last=performance.now();
            (function loop(now){const dt=(now-last)/1000; last=now; step(dt); draw(); requestAnimationFrame(loop)})(last);
        })();
        </script>
        </section>
        <!-- ===== /MICROCONTROLLER LOGIC • INTERRUPT SIMULATION ===== -->

        <section class="mb-16 max-w-6xl mx-auto p-6 bg-surface/50 rounded-lg shadow-xl border border-accent-glow/50">
            <h3
                class="text-xl md:text-2xl font-bold font-title-serif text-cyan-300 mb-4 uppercase tracking-wider border-b border-gray-700 pb-2">
                MICROCONTROLLER LOGIC: INTERRUPT SIMULATION
            </h3>

            <h2 class="text-xl font-bold mb-2 mt-4 text-cyan-300">Attiny85 Interrupt Animation</h2>
            <div id="attinyWrap" class="relative w-full mx-auto">
                <svg viewBox="0 0 900 500">
                    <defs>
                        <radialGradient id="glow" cx="50%" cy="50%" r="50%">
                            <stop offset="0%" stop-color="#22d3ee" />
                            <stop offset="100%" stop-color="#22d3ee" stop-opacity="0" />
                        </radialGradient>
                    </defs>
                    <!-- chip -->
                    <rect x="100" y="160" width="130" height="180" rx="10" class="chip" />
                    <text x="115" y="150" class="text">Attiny85</text>
                    <!-- pins -->
                    <rect x="90" y="180" width="10" height="16" class="pin" /><text x="60" y="192" class="text"
                        font-size="10">B5</text>
                    <rect x="90" y="210" width="10" height="16" class="pin" /><text x="60" y="222" class="text"
                        font-size="10">B3</text>
                    <rect x="90" y="240" width="10" height="16" class="pin" /><text x="60" y="252" class="text"
                        font-size="10">B4</text>
                    <rect x="90" y="270" width="10" height="16" class="pin" /><text x="55" y="282" class="text"
                        font-size="10">GND</text>
                    <rect x="230" y="180" width="10" height="16" class="pin" /><text x="245" y="192" class="text"
                        font-size="10">VCC</text>
                    <rect x="230" y="210" width="10" height="16" class="pin" /><text x="245" y="222" class="text"
                        font-size="10">B2</text>
                    <rect x="230" y="240" width="10" height="16" class="pin" /><text x="245" y="252" class="text"
                        font-size="10">B1</text>
                    <rect x="230" y="270" width="10" height="16" class="pin" /><text x="245" y="282" class="text"
                        font-size="10">B0</text>
                    <!-- wires -->
                    <path d="M240 190 C300 190 350 190 420 190 V 130 H 760" class="wire-red" />
                    <rect x="420" y="110" width="40" height="40" rx="5" class="button" />
                    <text x="470" y="100" class="text" font-size="16">Interrupt</text>
                    <!-- resistors -->
                    <path d="M240 250 H 430" class="wire" />
                    <rect x="430" y="240" width="60" height="20" rx="3" fill="#1e1b4b" stroke="#fca5a5"
                        stroke-width="2" />
                    <text x="440" y="235" class="text" font-size="12" fill="#fca5a5">100Ω</text>
                    <path d="M490 250 H 620" class="wire" />
                    <path d="M240 280 H 430" class="wire" />
                    <rect x="430" y="270" width="60" height="20" rx="3" fill="#1e1b4b" stroke="#fca5a5"
                        stroke-width="2" />
                    <text x="440" y="265" class="text" font-size="12" fill="#fca5a5">100Ω</text>
                    <path d="M490 280 H 620" class="wire" />
                    <!-- LEDs -->
                    <circle cx="650" cy="250" r="18" class="led" />
                    <circle cx="650" cy="250" r="60" class="led-glow led-on" />
                    <circle cx="650" cy="280" r="18" class="led" />
                    <circle cx="650" cy="280" r="60" class="led-glow led-on" style="animation-delay:1s" />
                    <!-- ground -->
                    <path d="M670 250 H 800 V 350 H 820" class="wire" />
                    <line x1="820" y1="350" x2="820" y2="380" stroke="#94a3b8" stroke-width="4" />
                    <line x1="805" y1="380" x2="835" y2="380" stroke="#94a3b8" stroke-width="3" />
                    <line x1="810" y1="388" x2="830" y2="388" stroke="#94a3b8" stroke-width="3" />
                </svg>

                <!-- how-it-works inline caption (inside canvas, bottom, non-blocking) -->
                <div id="attinyCaption" class="pointer-events-none absolute inset-x-0 bottom-0 mx-auto max-w-5xl">
                    <div
                        class="m-2 rounded-md border border-cyan-300/20 bg-slate-900/60 text-left shadow-lg shadow-cyan-500/10">
                        <div class="marquee text-[11px] leading-relaxed text-cyan-100/90 px-3 py-1">
                            <span class="track"><b class="text-emerald-300">Flow</b>: Interrupt rises → MCU B2 ISR →
                                toggles B1/B0 → through <span class="text-rose-300">100Ω</span> → LEDs light → return to
                                GND • <b class="text-emerald-300">Flow</b>: Interrupt rises → MCU B2 ISR → toggles B1/B0
                                → through <span class="text-rose-300">100Ω</span> → LEDs light → return to GND • </span>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <!-- END NEW SECTION -->


        <!-- ===== MICROCONTROLLER LOGIC • INTERRUPT SIMULATION (Info‑only, no animation) ===== -->
        <section id="mc-interrupts" class="mx-auto my-16 max-w-6xl ">
        <style>
            /* Scoped to #mc-interrupts to avoid leaks */
            #mc-interrupts{--smoke:#0d0f14;--panel:#1a1f29;--ink:#e8ecff;--muted:#9aa7c7;--neon:#00ff88;--cyan:#00cccc;--amber:#ff9a00}
            #mc-interrupts{background:radial-gradient(900px 320px at 30% 0, rgba(0,204,204,.05), transparent 60%),
                        radial-gradient(800px 280px at 80% -10%, rgba(255,154,0,.05), transparent 60%),
                        var(--smoke);border:1px solid rgba(255,255,255,.08);border-radius:14px;box-shadow:0 20px 60px rgba(0,0,0,.45)}
            #mc-interrupts .wrap{padding:28px}
            #mc-interrupts .title{margin:0 0 8px;font:800 22px/1.15 system-ui,-apple-system,Segoe UI,Inter,Roboto,Arial,sans-serif;letter-spacing:.3px}
            #mc-interrupts .title span{color:var(--neon);text-shadow:0 0 10px rgba(0,255,136,.45)}
            #mc-interrupts .sub{margin:0 0 18px;color:var(--muted)}
            #mc-interrupts .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:16px}
            #mc-interrupts .card{background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.015));border:1px solid rgba(255,255,255,.07);border-radius:12px;padding:16px}
            #mc-interrupts h3{margin:0 0 8px;font:700 14px/1.3 system-ui;color:var(--ink)}
            #mc-interrupts p, #mc-interrupts li{color:var(--muted);font:600 12px/1.55 system-ui;margin:0}
            #mc-interrupts ul{margin:0;padding-left:18px}
            #mc-interrupts .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(0,255,136,.12);color:var(--neon);font:800 11px/1 system-ui;letter-spacing:.4px}
            #mc-interrupts a{color:var(--cyan);text-decoration:underline;text-underline-offset:2px}
            #mc-interrupts .note{border-left:3px solid var(--amber);padding-left:10px;margin-top:10px}
        </style>

        <div class="wrap border border-[#ff5d00]">
            <h2 class="title"><span>MICROCONTROLLER LOGIC:</span> INTERRUPT SIMULATION</h2>
            <p class="sub">What interrupts are, how they work inside the CPU, and how to design reliable ISRs. Info‑only block — drop your own image or animation where indicated.</p>

            <div class="grid">
            <article class="card">
                <h3><span class="badge">Concept & Flow</span></h3>
                <ul>
                <li><b>Event → Pending</b>: Peripherals raise an <i>IRQ</i> line (timer tick, GPIO edge, UART RX).</li>
                <li><b>Priority & Masking</b>: The controller (e.g., NVIC on ARM) checks <i>enable</i>/<i>mask</i> bits and selects the highest priority source.</li>
                <li><b>Auto Context Save</b>: CPU pushes PC/PSR (+ regs on some cores) to the stack.</li>
                <li><b>Vector Fetch</b>: It jumps to the address stored in the vector table for that IRQ.</li>
                <li><b>ISR Duties</b>: Service hardware fast, acknowledge/clear the flag, queue work for later.</li>
                <li><b>Return</b>: A special instruction pops context and resumes the interrupted code.</li>
                </ul>
                <p class="note"><b>Tip:</b> Keep ISRs tiny. Do just the minimum, hand off heavy work to a queue or task.</p>
            </article>

            <article class="card">
                <h3><span class="badge">Types & Patterns</span></h3>
                <ul>
                <li><b>Level vs Edge</b>: Level stays active until cleared; edge fires on transitions (less CPU time).</li>
                <li><b>Nested / Preemptive</b>: Higher‑priority IRQs can preempt lower ones; set priorities carefully to avoid starvation.</li>
                <li><b>Debounce</b>: Mechanical inputs need filtering (RC, timer deferral, or digital debounce) to avoid IRQ storms.</li>
                <li><b>DMA + IRQ</b>: Use DMA for large transfers; the completion IRQ just switches buffers or signals a task.</li>
                <li><b>Critical Sections</b>: Briefly disable interrupts only around shared data updates (or use lock‑free ring buffers).</li>
                </ul>
            </article>

            <article class="card">
                <h3><span class="badge">Design Checklist</span></h3>
                <ul>
                <li>Define a clear <b>vector table</b> and document each source.</li>
                <li>Choose <b>stack size</b> for worst‑case nesting + RTOS context.</li>
                <li>Bound <b>latency</b>: measure from event to ISR entry; keep below your real‑time budget.</li>
                <li>Make ISRs <b>reentrant‑safe</b> or guard shared state.</li>
                <li>Use <b>volatile</b> for flags shared with main/RTOS tasks.</li>
                <li>Log rare faults (missed deadlines, overflowed FIFOs) to catch corner cases.</li>
                </ul>
            </article>

            <article class="card">
                <h3><span class="badge">Good References</span> (official + respected)</h3>
                <ul>
                <li>ARM Cortex‑M <b>NVIC</b> & vectoring (Arm Developer): <a href="https://developer.arm.com/documentation/dui0552/a/the-cortex-m3-processor/exception-model/nested-vectored-interrupt-controller--nvic" target="_blank">NVIC overview</a></li>
                <li>AVR/ATmega datasheet — external interrupts & pin‑change (Microchip): <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf" target="_blank">ATmega328P</a></li>
                <li>FreeRTOS: <a href="https://www.freertos.org/RTOS-Cortex-M3-M4.html" target="_blank">Interrupts on Cortex‑M & ISR safe APIs</a></li>
                <li>TI app note on <b>interrupt latency</b>: <a href="https://www.ti.com/lit/an/spraai5/spraai5.pdf" target="_blank">Measuring & minimizing</a></li>
                <li>Embedded Artistry: <a href="https://embeddedartistry.com/blog/2017/10/19/interrupts-a-primer/" target="_blank">Interrupts — a primer</a></li>
                </ul>
                <p class="note">Place your <b>image/diagram</b> here: replace this card with an &lt;img&gt; or embed your own waveform/oscilloscope snapshot.</p>
            </article>
            </div>
        </div>
        </section>
        <!-- ===== /MICROCONTROLLER LOGIC • INTERRUPT SIMULATION (Info‑only) ===== -->

        {% raw %}
        <!-- ===== System & Circuit • Compact Visualization Row (Smoky Black) ===== -->
       <section id="system-circuit-viz" aria-label="System & Circuit visualization"
            class="mt-40 lg:mt-56 xl:mt-[160px] mb-40 max-w-6xl mx-auto rounded-lg shadow-xl border border-[#ff5d00]">
            <style>
                /* Scoped styles — paste anywhere safely */
                #system-circuit-viz {
                    --smoke: #0d0f14;
                    --panel: #0f172a;
                    --ink: #e8ecff;
                    --muted: #9aa7c7;
                    --cyn: #00cccc;
                    --amb: #f59e0b;
                    --grn: #10b981;
                    --blu: #3b82f6;
                    --red: #ef4444
                }

                #system-circuit-viz {
                    position: relative;
                    padding: 32px 16px;
                    background:
                        radial-gradient(1200px 420px at 10% -10%, rgba(0, 204, 204, .06), transparent 60%),
                        radial-gradient(900px 360px at 90% -20%, rgba(245, 158, 11, .05), transparent 60%),
                        linear-gradient(180deg, rgba(255, 255, 255, .02), rgba(255, 255, 255, 0)),
                        var(--smoke);
                    color: var(--ink)
                }

                #system-circuit-viz:before {
                    content: "";
                    position: absolute;
                    inset: 0;
                    background:
                        radial-gradient(800px 280px at 50% 0, rgba(0, 0, 0, .35), transparent 70%);
                    pointer-events: none
                }

                #system-circuit-viz .wrap {
                    max-width: 1100px;
                    margin: 0 auto
                }

                #system-circuit-viz .title {
                    margin: 0 0 6px;
                    text-align: center;
                    font: 800 28px/1.15 system-ui, -apple-system, Segoe UI, Inter, Roboto, Arial, sans-serif
                }

                #system-circuit-viz .brand {
                    background: linear-gradient(90deg, var(--cyn), #6366f1, var(--amb), #22c55e);
                    -webkit-background-clip: text;
                    background-clip: text;
                    color: transparent;
                    background-size: 200% 100%;
                    animation: sc-shimmer 3.5s linear infinite
                }

                @keyframes sc-shimmer {
                    to {
                        background-position: 200% 0
                    }
                }

                #system-circuit-viz .sub {
                    margin: 0 0 20px;
                    text-align: center;
                    color: var(--muted)
                }

                #system-circuit-viz .grid {
                    display: grid;
                    grid-template-columns: repeat(4, minmax(0, 1fr));
                    gap: 14px
                }

                @media(max-width:1024px) {
                    #system-circuit-viz .grid {
                        grid-template-columns: repeat(2, minmax(0, 1fr))
                    }
                }

                @media(max-width:640px) {
                    #system-circuit-viz .grid {
                        grid-template-columns: 1fr
                    }
                }

                #system-circuit-viz .card {
                    display: flex;
                    flex-direction: column;
                    background: linear-gradient(180deg, rgba(255, 255, 255, .04), rgba(255, 255, 255, .02));
                    border: 1px solid rgba(255, 255, 255, .08);
                    border-radius: 12px;
                    padding: 12px;
                    min-height: 240px;
                    box-shadow: 0 20px 50px rgba(0, 0, 0, .45), inset 0 0 0 1px rgba(0, 204, 204, .05);
                    transition: transform .25s ease, box-shadow .25s ease
                }

                #system-circuit-viz .card:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 34px 80px rgba(0, 0, 0, .55), 0 0 0 1px rgba(0, 204, 204, .06)
                }

                #system-circuit-viz h3 {
                    margin: 0 0 6px;
                    font: 700 15px/1.25 system-ui
                }

                #system-circuit-viz p.desc {
                    margin: 0 0 10px;
                    color: var(--muted);
                    font: 600 11px/1.35 system-ui
                }

                #system-circuit-viz .canvas-wrap {
                    position: relative
                }

                #system-circuit-viz canvas {
                    width: 100%;
                    height: auto;
                    display: block;
                    background: radial-gradient(700px 260px at 50% 0, rgba(0, 204, 204, .05), transparent 60%), var(--panel);
                    border: 1px solid #1e293b;
                    border-radius: 8px
                }
            </style>

            <div class="wrap">
                <header class="head">
                    <h2 class="title"><span class="brand">System &amp; Circuit</span> — Visualization Suite</h2>
                    <p class="sub">Four compact live demos: signal flow, MOSFET I–V, AC Bode sweep, and oscillator phase
                        orbit.</p>
                </header>

                <div id="sc-grid" class="grid">
                    <div id="module-waveform" class="card"></div>
                    <div id="module-iv" class="card"></div>
                    <div id="module-bode" class="card"></div>
                    <div id="module-orbit" class="card"></div>
                </div>
            </div>

            <script>
                // === Config ===
                const CANVAS_WIDTH = 200, CANVAS_HEIGHT = 90, SCHEMATIC_HEIGHT = 80;
                const BG_COLOR = '#0f172a', GRID_COLOR = '#1e293b', AXIS_COLOR = '#94a3b8';
                const TRACE_COLORS = ['#10b981', '#f59e0b', '#3b82f6', '#ef4444'];

                // === Helpers ===
                const drawGrid = (ctx, w, h, xd, yd) => { ctx.strokeStyle = GRID_COLOR; ctx.lineWidth = 0.5; for (let i = 0; i <= yd; i++) { const y = i * h / yd; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke() } for (let j = 0; j <= xd; j++) { const x = j * w / xd; ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke() } };
                const drawText = (ctx, txt, x, y, col = AXIS_COLOR, align = 'left', size = 9) => { ctx.font = `${size}px Inter,system-ui,sans-serif`; ctx.fillStyle = col; ctx.textAlign = align; ctx.fillText(txt, x, y) };
                const createCanvas = (parentId, id, w, h) => { const c = document.createElement('canvas'); c.id = id; c.width = w; c.height = h; document.getElementById(parentId).appendChild(c); return c.getContext('2d') };
                const createSchematic = (parentId, staticId, dragId, w, h) => { const parent = document.getElementById(parentId); const wrap = document.createElement('div'); wrap.className = 'canvas-wrap'; wrap.style.height = `${h}px`; const s = document.createElement('canvas'); s.id = staticId; s.width = w; s.height = h; s.className = 'absolute'; wrap.appendChild(s); const d = document.createElement('canvas'); d.id = dragId; d.width = w; d.height = h; d.className = 'absolute'; wrap.appendChild(d); parent.appendChild(wrap); return { staticCtx: s.getContext('2d'), dragCtx: d.getContext('2d'), dragCanvas: d } };

                class Draggable { constructor(canvas, draw, x, y, b) { this.canvas = canvas; this.ctx = canvas.getContext('2d'); this.drawComp = draw; this.x = x; this.y = y; this.bounds = b; this.drag = false; this.offX = 0; this.offY = 0; canvas.addEventListener('mousedown', this.md); canvas.addEventListener('mousemove', this.mm); canvas.addEventListener('mouseup', this.mu); canvas.addEventListener('mouseleave', this.mu); this.redraw() } in(mx, my) { const { x, y, w, h } = this.bounds; return mx >= this.x + x && mx <= this.x + x + w && my >= this.y + y && my <= this.y + y + h } md = (e) => { const r = this.canvas.getBoundingClientRect(); const mx = (e.clientX - r.left) * (this.canvas.width / r.width); const my = (e.clientY - r.top) * (this.canvas.height / r.height); if (this.in(mx, my)) { this.drag = true; this.offX = mx - this.x; this.offY = my - this.y; this.canvas.style.cursor = 'grabbing' } }; mm = (e) => { const r = this.canvas.getBoundingClientRect(); const mx = (e.clientX - r.left) * (this.canvas.width / r.width); const my = (e.clientY - r.top) * (this.canvas.height / r.height); if (this.drag) { this.x = mx - this.offX; this.y = my - this.offY; this.redraw() } else { this.canvas.style.cursor = this.in(mx, my) ? 'grab' : 'default' } }; mu = () => { this.drag = false; this.canvas.style.cursor = 'default' }; redraw() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.save(); this.ctx.translate(this.x, this.y); this.drawComp(this.ctx); this.ctx.restore() } }

                // === Module 1: Signal Flow (Analog↔Digital) ===
                const setupWaveform = (parentId) => { const plot = createCanvas(parentId, 'wave-plot', CANVAS_WIDTH, CANVAS_HEIGHT); const sch = createSchematic(parentId, 'wave-sch-s', 'wave-sch-d', CANVAS_WIDTH, SCHEMATIC_HEIGHT); const staticCtx = sch.staticCtx, movingCtx = sch.dragCtx; const MCU_W = 100, MCU_H = 60; const baseX = (CANVAS_WIDTH - MCU_W) / 2, baseY = (SCHEMATIC_HEIGHT - MCU_H) / 2; let mcuX = baseX, mcuY = baseY, t = 0, hist = []; const traces = [{ color: TRACE_COLORS[0], off: 15 }, { color: TRACE_COLORS[1], off: 30 }, { color: TRACE_COLORS[2], off: 45 }]; const drawMCU = (ctx, x, y) => { ctx.save(); ctx.translate(x, y); ctx.strokeStyle = AXIS_COLOR; ctx.lineWidth = 2; ctx.strokeRect(0, 0, MCU_W, MCU_H); drawText(ctx, 'MCU', 5, 10, AXIS_COLOR, 'left', 10); traces.forEach(tr => { ctx.beginPath(); ctx.moveTo(MCU_W, tr.off); ctx.lineTo(MCU_W + 5, tr.off); ctx.stroke() }); ctx.restore() }; const wires = (ctx, x, y) => { ctx.fillStyle = BG_COLOR; ctx.fillRect(0, 0, CANVAS_WIDTH, SCHEMATIC_HEIGHT); ctx.strokeStyle = AXIS_COLOR; ctx.lineWidth = 2; const start = MCU_W + 5; traces.forEach((tr, i) => { const py = y + tr.off; ctx.beginPath(); ctx.moveTo(x + start, py); ctx.lineTo(x + start + 25, py); ctx.stroke(); ctx.fillStyle = tr.color; ctx.beginPath(); ctx.arc(x + start + 10, py, 3, 0, 6.283); ctx.fill(); drawText(ctx, ['OUT_A', 'OUT_D', 'OUT_R'][i], x + start + 20, py + 3, tr.color, 'left', 9) }) }; const drawPlot = (ctx) => { const w = ctx.canvas.width, h = ctx.canvas.height; ctx.fillStyle = BG_COLOR; ctx.fillRect(0, 0, w, h); drawGrid(ctx, w, h, 8, 5); const fns = [tt => 2.5 + 2 * Math.sin(2 * Math.PI * 1 * tt), tt => 1.5 * Math.sign(Math.sin(2 * Math.PI * 2 * tt)) + 2.5, tt => 4.5 - (tt * 5) % 3];[0, 1, 2].forEach(i => { if (hist.length < 2) return; ctx.strokeStyle = traces[i].color; ctx.lineWidth = 2; ctx.beginPath(); hist.forEach((d, idx) => { const v = fns[i](d.t), x = idx / hist.length * w, y = h * (1 - v / 5); idx ? ctx.lineTo(x, y) : ctx.moveTo(x, y) }); ctx.stroke() }) }; (function loop() { t += 1 / 60; mcuX = baseX + 25 * Math.sin(t * 1.5); mcuY = baseY + 15 * Math.cos(t * 1.0); hist.push({ t }); if (hist.length > 180) hist.shift(); wires(staticCtx, mcuX, mcuY); movingCtx.clearRect(0, 0, CANVAS_WIDTH, SCHEMATIC_HEIGHT); drawMCU(movingCtx, mcuX, mcuY); drawPlot(plot); requestAnimationFrame(loop) })() };

                // === Module 2: I–V Curve (Drag MOSFET) ===
                const Vt = 1.0, VMAX = 5.0, IMAX = 5.0, MS = 25; const Id = (Vgs, Vds) => Vgs < Vt ? 0 : (Vds < (Vgs - Vt) ? 0.5 * (Vgs - Vt) * Vds - 0.1 * Vds * Vds : 0.5 * (Vgs - Vt) * (Vgs - Vt));
                const setupIV = (parentId) => { const plot = createCanvas(parentId, 'iv-plot', CANVAS_WIDTH, CANVAS_HEIGHT); const sch = createSchematic(parentId, 'iv-sch-s', 'iv-sch-d', CANVAS_WIDTH, SCHEMATIC_HEIGHT); const sctx = sch.staticCtx, dcv = sch.dragCanvas; const drawMOS = (ctx) => { ctx.strokeStyle = AXIS_COLOR; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-MS / 2, -MS); ctx.lineTo(-MS / 2, MS); ctx.moveTo(MS / 2, -MS); ctx.lineTo(MS / 2, MS); ctx.moveTo(-MS, 0); ctx.lineTo(-MS / 2, 0); ctx.stroke(); drawText(ctx, 'D', MS / 2 + 3, -MS - 5); drawText(ctx, 'S', MS / 2 + 3, MS + 10); drawText(ctx, 'G', -MS - 5, 5) }; const wires = (ctx, x, y) => { ctx.fillStyle = BG_COLOR; ctx.fillRect(0, 0, CANVAS_WIDTH, SCHEMATIC_HEIGHT); ctx.strokeStyle = AXIS_COLOR; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(x + MS / 2, y - MS); ctx.lineTo(x + MS / 2 + 15, y - MS); ctx.moveTo(x + MS / 2, y + MS); ctx.lineTo(x + MS / 2 + 15, y + MS); ctx.moveTo(x - MS, y); ctx.lineTo(x - MS - 15, y); ctx.stroke() }; const mos = new Draggable(dcv, drawMOS, (CANVAS_WIDTH - MS) / 2, SCHEMATIC_HEIGHT / 2, { x: -MS - 5, y: -MS - 10, w: MS * 2 + 15, h: MS * 2 + 20 }); let sweep = 0; function drawPlot(ctx, vd) { const w = ctx.canvas.width, h = ctx.canvas.height; ctx.fillStyle = BG_COLOR; ctx.fillRect(0, 0, w, h); drawGrid(ctx, w, h, 5, 5); ctx.strokeStyle = AXIS_COLOR; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, h); ctx.lineTo(w, h); ctx.moveTo(0, 0); ctx.lineTo(0, h); ctx.stroke(); for (let Vgs = 1; Vgs <= 5; Vgs++) { ctx.strokeStyle = TRACE_COLORS[2]; ctx.lineWidth = 2; ctx.beginPath(); const maxVds = Math.min(vd, VMAX); for (let Vds = 0; Vds <= maxVds; Vds += 0.1) { const I = Math.min(Id(Vgs, Vds) * 3, IMAX); const x = Vds * (w / VMAX); const y = h * (1 - I / IMAX); Vds ? ctx.lineTo(x, y) : ctx.moveTo(x, y) } ctx.stroke(); drawText(ctx, `Vgs=${Vgs}V`, 5, h * (1 - 0.5 - Vgs * 0.05), '#93c5fd', 'left', 7) } const cx = (performance.now() / 12) % w; ctx.setLineDash([4, 6]); ctx.strokeStyle = 'rgba(245,158,11,.9)'; ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, h); ctx.stroke(); ctx.setLineDash([]) } (function loop() { sweep = (sweep + 0.05) % (VMAX * 2); const vd = sweep <= VMAX ? sweep : VMAX; wires(sctx, mos.x, mos.y); drawPlot(plot, vd); if (!mos.drag) mos.redraw(); requestAnimationFrame(loop) })() };

                // === Module 3: AC Bode (Live Sweep) ===
                const bodeY = (x, h) => { const H = h / 2, fc = CANVAS_WIDTH / 3; let mag = H * (1 - 0.5 * Math.atan(x / fc) / (Math.PI / 2)) - H / 4; mag = Math.max(H / 4, Math.min(H * 0.75, mag)); const ph = H * (1 + 0.5 * Math.atan(x / fc) / (Math.PI / 2)); return { magY: mag, phaseY: ph } };
                const setupBode = (parentId) => { const plot = createCanvas(parentId, 'bode-plot', CANVAS_WIDTH, CANVAS_HEIGHT); const sch = createCanvas(parentId, 'bode-sch', CANVAS_WIDTH, SCHEMATIC_HEIGHT); let cx = 0; const drawSch = (ctx) => { const w = ctx.canvas.width, h = ctx.canvas.height; ctx.fillStyle = BG_COLOR; ctx.fillRect(0, 0, w, h); ctx.strokeStyle = AXIS_COLOR; ctx.lineWidth = 2; const Cx = w / 2, Cy = h / 2, R = 25; ctx.beginPath(); ctx.moveTo(Cx - 70, Cy); ctx.lineTo(Cx - 35, Cy); ctx.stroke(); drawText(ctx, 'V_in', Cx - 60, Cy - 10); ctx.strokeRect(Cx - 35, Cy - 8, R, 16); drawText(ctx, 'R1', Cx - 30, Cy - 15); ctx.beginPath(); ctx.moveTo(Cx - 10, Cy); ctx.lineTo(Cx + 5, Cy); ctx.stroke(); ctx.beginPath(); ctx.moveTo(Cx + 5, Cy - 16); ctx.lineTo(Cx + 5, Cy + 16); ctx.moveTo(Cx + 15, Cy - 16); ctx.lineTo(Cx + 15, Cy + 16); ctx.stroke(); drawText(ctx, 'C1', Cx + 10, Cy - 20, '#94a3b8', 'center'); ctx.beginPath(); ctx.moveTo(Cx + 15, Cy); ctx.lineTo(Cx + 45, Cy); ctx.stroke(); drawText(ctx, 'V_out', Cx + 25, Cy - 10); ctx.beginPath(); ctx.moveTo(Cx + 10, Cy + 16); ctx.lineTo(Cx + 10, Cy + 30); ctx.moveTo(Cx - 5, Cy + 30); ctx.lineTo(Cx + 25, Cy + 30); ctx.stroke() }; const draw = (ctx, x) => { const w = ctx.canvas.width, h = ctx.canvas.height; ctx.fillStyle = BG_COLOR; ctx.fillRect(0, 0, w, h); const H = h / 2; ctx.save(); ctx.rect(0, 0, w, H); ctx.clip(); drawGrid(ctx, w, H, 5, 3); drawText(ctx, 'Mag (dB)', 5, 10); drawText(ctx, '0 dB', 5, H / 2); ctx.strokeStyle = TRACE_COLORS[2]; ctx.lineWidth = 2; ctx.beginPath(); for (let i = 0; i <= w; i++) { const { magY } = bodeY(i, h); i ? ctx.lineTo(i, magY) : ctx.moveTo(i, magY) } ctx.stroke(); ctx.restore(); ctx.save(); ctx.translate(0, H); ctx.rect(0, 0, w, H); ctx.clip(); drawGrid(ctx, w, H, 5, 3); drawText(ctx, 'Phase (°)', 5, 10); drawText(ctx, '0°', 5, H / 2); drawText(ctx, '-90°', 5, H - 10); ctx.strokeStyle = TRACE_COLORS[3]; ctx.lineWidth = 2; ctx.beginPath(); for (let i = 0; i <= w; i++) { const { phaseY } = bodeY(i, h); i ? ctx.lineTo(i, phaseY - H) : ctx.moveTo(i, phaseY - H) } ctx.stroke(); ctx.restore(); drawText(ctx, 'Freq (Hz)', w - 5, h - 5, AXIS_COLOR, 'right'); ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); ctx.setLineDash([]); const c = bodeY(x, h); ctx.fillStyle = TRACE_COLORS[2]; ctx.beginPath(); ctx.arc(x, c.magY, 3, 0, 6.283); ctx.fill(); ctx.fillStyle = TRACE_COLORS[3]; ctx.beginPath(); ctx.arc(x, c.phaseY, 3, 0, 6.283); ctx.fill() }; (function loop() { cx = (cx + 1) % CANVAS_WIDTH; draw(plot, cx); drawSch(sch); requestAnimationFrame(loop) })() };

                // === Module 4: XY Orbit ===
                const setupOrbit = (parentId) => { const plot = createCanvas(parentId, 'orb-plot', CANVAS_WIDTH, CANVAS_HEIGHT); const sch = createCanvas(parentId, 'orb-sch', CANVAS_WIDTH, SCHEMATIC_HEIGHT); let t = 0, path = []; const drawSch = (ctx) => { const w = ctx.canvas.width, h = ctx.canvas.height; ctx.fillStyle = BG_COLOR; ctx.fillRect(0, 0, w, h); ctx.strokeStyle = AXIS_COLOR; ctx.lineWidth = 2; const Cx = w / 2, Cy = h / 2, opW = 60, opH = 40; ctx.strokeRect(Cx - opW / 2, Cy - opH / 2, opW, opH); drawText(ctx, 'Oscillator', Cx, Cy + 5, AXIS_COLOR, 'center'); ctx.beginPath(); ctx.arc(Cx - 40, Cy, 8, 0, 6.283); ctx.moveTo(Cx + opW / 2, Cy); ctx.lineTo(Cx + 80, Cy); ctx.stroke(); drawText(ctx, 'V1', Cx - 48, Cy, TRACE_COLORS[0]); drawText(ctx, 'V2', Cx + 40, Cy - 40, TRACE_COLORS[1], 'center') }; const draw = (ctx, pts) => { const w = ctx.canvas.width, h = ctx.canvas.height; ctx.fillStyle = BG_COLOR; ctx.fillRect(0, 0, w, h); drawGrid(ctx, w, h, 5, 5); const Cx = w / 2, Cy = h / 2; ctx.strokeStyle = AXIS_COLOR; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(Cx, 0); ctx.lineTo(Cx, h); ctx.moveTo(0, Cy); ctx.lineTo(w, Cy); ctx.stroke(); drawText(ctx, 'V1', w - 10, Cy - 5); drawText(ctx, 'V2', Cx + 5, 10); if (pts.length < 2) return; ctx.strokeStyle = TRACE_COLORS[3]; ctx.lineWidth = 2; ctx.beginPath(); pts.forEach((p, i) => { const x = Cx + p.v1 * Cx * 0.9, y = Cy - p.v2 * Cy * 0.9; i ? ctx.lineTo(x, y) : ctx.moveTo(x, y) }); ctx.stroke(); const last = pts[pts.length - 1]; ctx.fillStyle = TRACE_COLORS[3]; ctx.beginPath(); ctx.arc(Cx + last.v1 * Cx * 0.9, Cy - last.v2 * Cy * 0.9, 3, 0, 6.283); ctx.fill() }; (function loop() { t += 1 / 60; const v1 = Math.cos(t * 1.0), v2 = Math.sin(t * 1.5); path.push({ v1, v2 }); if (path.length > 500) path.shift(); draw(plot, path); drawSch(sch); requestAnimationFrame(loop) })() };

                // === Boot ===
                (function init() { setupWaveform('module-waveform'); setupIV('module-iv'); setupBode('module-bode'); setupOrbit('module-orbit') })();
            </script>
        </section>
        <!-- ===== /System & Circuit Section ===== -->
        {% endraw %}

    </main>
   <!-- Professional Footer (New) -->
  <footer id="contact" class="w-full bg-surface border-t-1 border-transparent animated-footer mt-56">
    <div class="max-w-7xl mx-auto p-8 text-primary-text/80 text-sm">
      <div class="grid grid-cols-2 md:grid-cols-4 gap-8">
        <!-- Brand/Mission -->
        <div class="col-span-2 md:col-span-1">
          <h3 class="text-2xl font-title-serif font-bold text-accent-glow tracking-widest transition duration-500 hover:text-cyan-300 mb-4">ApitCraft Medical</h3>
          <p class="text-sm">Innovating medical visualization through interactive 3D modeling and data integration for education and professional development.</p>
        </div>

        <!-- Quick Links (Placeholder for structure) -->
        <div>
          <h4 class="text-lg font-semibold text-accent-glow">Navigation</h4>
          <ul class="space-y-2 text-sm">
            <li><a href="#video-hub" class="hover:text-accent-glow transition duration-200">Video Lab</a></li>
            <li><a href="#three-d-hub" class="hover:text-accent-glow transition duration-200">3D Hub</a></li>
            <li><a href="#brain-hub" class="hover:text-accent-glow transition duration-200">Brain Hub</a></li>
          </ul>
        </div>

        <!-- Contact Information -->
        <div class="col-span-2 md:col-span-2">
          <h4 class="text-lg font-semibold text-accent-glow">Connect with the Developer</h4>
          <ul class="space-y-3 text-sm">
            <!-- Website -->
            <li>
              <a href="https://flask-apps-e45a.onrender.com/" target="_blank" class="flex items-center space-x-2 hover:text-accent-glow transition duration-200">
                <i class="fa-solid fa-globe w-5 text-accent-glow"></i>
                <span>Website: flask-apps-e45a.onrender.com</span>
              </a>
            </li>
            <!-- Email -->
            <li>
              <a href="mailto:afsanaafroze21@gmail.com" class="flex items-center space-x-2 hover:text-accent-glow transition duration-200">
                <i class="fa-solid fa-envelope w-5 text-accent-glow"></i>
                <span>Email: afsanaafroze21@gmail.com</span>
              </a>
            </li>
            <!-- LinkedIn -->
            <li>
              <a href="https://www.linkedin.com/in/afsanausa/" target="_blank" class="flex items-center space-x-2 hover:text-accent-glow transition duration-200">
                <i class="fa-brands fa-linkedin w-5 text-accent-glow"></i>
                <span>LinkedIn: afsanausa</span>
              </a>
            </li>
            <!-- GitHub -->
            <li>
              <a href="https://github.com/Afsana721/flask_apps" target="_blank" class="flex items-center space-x-2 hover:text-accent-glow transition duration-200">
                <i class="fa-brands fa-github w-5 text-accent-glow"></i>
                <span>GitHub: Afsana721/flask_apps</span>
              </a>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="mt-10 border-t border-primary-text/20 pt-6 text-center text-xs text-primary-text/60">
      <p>&copy; 2025 ApitCraft. All rights reserved. Design and Development by Afsana Afroze.</p>
    </div>
  </footer>
  <!-- End of Professional Footer -->

    <script>
        // ====================================================================
        // EXISTING 2D CIRCUIT SIMULATION LOGIC (on #circuitCanvas) - REMAINS ANIMATED
        // ====================================================================
        const canvas = document.getElementById('circuitCanvas');
        const ctx = canvas.getContext('2d');
        const container = canvas.parentElement;

        let componentCounter = 1;

        // --- Component Data ---
        // Initial setup for a simple RLC series circuit
        let components = [
            { id: 'V1', type: 'source', x: 100, y: 200, width: 40, height: 40, isDragging: false, charge: 1, color: 'source-red' },
            { id: 'R1', type: 'resistor', x: 250, y: 200, width: 80, height: 20, isDragging: false, color: '#FFFFFF' },
            { id: 'C1', type: 'capacitor', x: 400, y: 200, width: 60, height: 30, isDragging: false, charge: 0, color: '#FFFFFF' },
            { id: 'L1', type: 'inductor', x: 550, y: 200, width: 80, height: 20, isDragging: false, charge: 0, color: '#FFFFFF' }
        ];

        // --- Electron Animation Data ---
        let electrons = [];
        const ELECTRON_COUNT = 30;
        const ELECTRON_SPEED = 2;
        const ELECTRON_RADIUS = 2.5;
        let animationTime = 0;

        // --- Initialization and Resizing ---
        function resizeCircuitCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        window.addEventListener('resize', resizeCircuitCanvas);
        resizeCircuitCanvas();

        // Initialize electrons
        for (let i = 0; i < ELECTRON_COUNT; i++) {
            electrons.push({
                t: i / ELECTRON_COUNT,
                speed: ELECTRON_SPEED * (0.8 + Math.random() * 0.4)
            });
        }

        // --- Drawing Helper Functions (2D) ---

        function drawComponent(comp, drawFn) {
            ctx.save();
            ctx.translate(comp.x, comp.y);
            drawFn(comp);

            // Draw label
            ctx.fillStyle = comp.isDragging ? tailwind.config.theme.extend.colors['accent-glow'] : '#FFFFFF';
            ctx.font = '12px Inter';
            ctx.textAlign = 'center';
            ctx.fillText(comp.id, 0, -comp.height / 2 - 10);

            ctx.restore();
        }

        // --- Component Drawing Logic (2D) ---

        function drawResistor(comp) {
            const w = comp.width;
            const h = comp.height;
            const lineW = 2;

            // Draw leads
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = lineW;
            ctx.beginPath();
            ctx.moveTo(-w / 2 - 10, 0); ctx.lineTo(-w / 2, 0);
            ctx.moveTo(w / 2, 0); ctx.lineTo(w / 2 + 10, 0);
            ctx.stroke();

            // Draw zig-zag body
            ctx.strokeStyle = comp.isDragging ? tailwind.config.theme.extend.colors['accent-glow'] : '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(-w / 2, 0);
            const segments = 6;
            for (let i = 1; i <= segments; i++) {
                const px = -w / 2 + (i * w) / segments;
                const py = (i % 2 === 0 ? 0 : (i % 4 === 1 ? h / 2 : -h / 2));
                ctx.lineTo(px, py);
            }
            ctx.stroke();
        }

        function drawCapacitor(comp) {
            const w = comp.width;
            const h = comp.height;
            const plateGap = 5;
            const lineW = 2;

            // Draw leads
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = lineW;
            ctx.beginPath();
            ctx.moveTo(-w / 2 - 10, 0); ctx.lineTo(-w / 2, 0);
            ctx.moveTo(w / 2, 0); ctx.lineTo(w / 2 + 10, 0);
            ctx.stroke();

            // Plate 1 (Static)
            ctx.strokeStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(-plateGap / 2, -h / 2);
            ctx.lineTo(-plateGap / 2, h / 2);
            ctx.stroke();

            // Plate 2 (Animation: Glow indicates charge accumulation)
            const glow = Math.sin(animationTime * 0.05) * 0.5 + 0.5; // Oscillates 0 to 1
            ctx.shadowColor = `rgba(0, 255, 127, ${glow})`;
            ctx.shadowBlur = 15 * glow;
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 + glow * 0.5})`;
            ctx.beginPath();
            ctx.moveTo(plateGap / 2, -h / 2);
            ctx.lineTo(plateGap / 2, h / 2);
            ctx.stroke();

            ctx.shadowBlur = 0; // Reset shadow
        }

        function drawSource(comp) {
            const w = comp.width;
            const h = comp.height;
            const lineW = 2;

            // Draw leads
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = lineW;
            ctx.beginPath();
            ctx.moveTo(-w / 2 - 10, 0); ctx.lineTo(-w / 2, 0);
            ctx.moveTo(w / 2, 0); ctx.lineTo(w / 2 + 10, 0);
            ctx.stroke();

            // Positive Plate (Longer, Red)
            ctx.strokeStyle = tailwind.config.theme.extend.colors['source-red'];
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-w / 2 + 5, -h / 2);
            ctx.lineTo(-w / 2 + 5, h / 2);
            ctx.stroke();

            // Negative Plate (Shorter, Blue)
            ctx.strokeStyle = tailwind.config.theme.extend.colors['source-blue'];
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(w / 2 - 5, -h / 4);
            ctx.lineTo(w / 2 - 5, h / 4);
            ctx.stroke();
        }

        function drawInductor(comp) {
            const w = comp.width;
            const h = comp.height;
            const lineW = 2;
            const coilH = h / 2;

            // Draw leads
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = lineW;
            ctx.beginPath();
            ctx.moveTo(-w / 2 - 10, 0); ctx.lineTo(-w / 2, 0);
            ctx.moveTo(w / 2, 0); ctx.lineTo(w / 2 + 10, 0);
            ctx.stroke();

            // Draw coil (Animation: Glow indicates magnetic field energy)
            const glow = Math.abs(Math.sin(animationTime * 0.025)); // Pulses 0 to 1
            ctx.shadowColor = tailwind.config.theme.extend.colors['inductor-coil'];
            ctx.shadowBlur = 10 * glow;
            ctx.strokeStyle = `rgba(255, 255, 0, ${0.5 + glow * 0.5})`;
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(-w / 2, 0);
            const loops = 4;
            const loopW = w / loops;
            for (let i = 0; i < loops; i++) {
                // First half arc
                ctx.arcTo(-w / 2 + i * loopW + loopW / 2, coilH, -w / 2 + (i + 1) * loopW, 0, loopW / 2);
                // Second half arc
                ctx.arcTo(-w / 2 + i * loopW + loopW * 1.5, -coilH, -w / 2 + (i + 2) * loopW, 0, loopW / 2);
            }
            ctx.lineTo(w / 2, 0);
            ctx.stroke();

            ctx.shadowBlur = 0; // Reset shadow
        }

        function drawICChip(comp) {
            // IC Chips are disabled in the palette but we keep the draw function for completeness
            const w = 50;
            const h = 40;
            ctx.fillStyle = tailwind.config.theme.extend.colors['ic-chip'];
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;

            // Chip body
            ctx.fillRect(-w / 2, -h / 2, w, h);
            ctx.strokeRect(-w / 2, -h / 2, w, h);

            // Pins (Mockup)
            ctx.fillStyle = '#FFFFFF';
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.arc(-w / 2 - 5, -h / 2 + 5 + i * 10, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(w / 2 + 5, -h / 2 + 5 + i * 10, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawWires() {
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            ctx.beginPath();

            // Connect all components in a series loop
            components.forEach((comp, index) => {
                const nextComp = components[(index + 1) % components.length];
                const startX = comp.x + comp.width / 2 + 10;
                const startY = comp.y;
                const endX = nextComp.x - nextComp.width / 2 - 10;
                const endY = nextComp.y;

                if (index === 0) {
                    ctx.moveTo(startX, startY);
                } else {
                    // Draw segment from previous component to current component
                    ctx.moveTo(components[index - 1].x + components[index - 1].width / 2 + 10, components[index - 1].y);
                }

                // Simplified L-shaped connection for demonstration
                ctx.lineTo(startX, startY);

                // Draw connecting wire
                const midX = (startX + endX) / 2;
                ctx.lineTo(midX, startY);
                ctx.lineTo(midX, endY);
                ctx.lineTo(endX, endY);
            });

            // Close the loop from the last component back to the first
            const firstComp = components[0];
            const lastComp = components[components.length - 1];
            const startX = lastComp.x + lastComp.width / 2 + 10;
            const startY = lastComp.y;
            const endX = firstComp.x - firstComp.width / 2 - 10;
            const endY = firstComp.y;

            const midX1 = (startX + endX) / 2;
            ctx.moveTo(startX, startY);
            ctx.lineTo(midX1, startY);
            ctx.lineTo(midX1, endY);
            ctx.lineTo(endX, endY);

            ctx.stroke();
        }

        function drawElectrons() {
            ctx.fillStyle = tailwind.config.theme.extend.colors['electron'];
            ctx.shadowColor = tailwind.config.theme.extend.colors['electron'];
            ctx.shadowBlur = 8;

            // Dynamic path points based on current component layout
            let dynamicPath = [];
            components.forEach((comp, index) => {
                const nextComp = components[(index + 1) % components.length];
                // Start of the connection wire
                dynamicPath.push({ x: comp.x + comp.width / 2, y: comp.y });

                const startX = comp.x + comp.width / 2 + 10;
                const startY = comp.y;
                const endX = nextComp.x - nextComp.width / 2 - 10;
                const endY = nextComp.y;

                // Add points for the wire segment (Component Out -> Next Component In)
                const midX = (startX + endX) / 2;
                dynamicPath.push({ x: startX, y: startY });
                dynamicPath.push({ x: midX, y: startY });
                dynamicPath.push({ x: midX, y: endY });
                dynamicPath.push({ x: endX, y: endY });

                // End of the connection wire (at the component boundary)
                dynamicPath.push({ x: nextComp.x - nextComp.width / 2, y: nextComp.y });
            });

            // Normalize total path length
            let distances = [0];
            let totalLength = 0;
            for (let i = 0; i < dynamicPath.length - 1; i++) {
                const p1 = dynamicPath[i];
                const p2 = dynamicPath[i + 1];
                const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                totalLength += dist;
                distances.push(totalLength);
            }

            electrons.forEach(e => {
                // Use cosine to simulate an oscillating current flow (AC behavior for better animation)
                const currentMultiplier = (Math.cos(animationTime * 0.05) + 2) / 3; // Always positive
                e.t += (e.speed * 0.0005 * currentMultiplier);
                if (e.t > 1) e.t = 0;

                const targetDist = e.t * totalLength;

                let p1 = null;
                let p2 = null;
                let segmentStartDist = 0;
                let segmentEndDist = totalLength;

                for (let i = 0; i < dynamicPath.length - 1; i++) {
                    if (targetDist >= distances[i] && targetDist <= distances[i + 1]) {
                        p1 = dynamicPath[i];
                        p2 = dynamicPath[i + 1];
                        segmentStartDist = distances[i];
                        segmentEndDist = distances[i + 1];
                        break;
                    }
                    if (targetDist < distances[i]) break; // Optimization: path is sorted
                }

                // Fallback for last segment (if loop logic misses)
                if (!p1 && dynamicPath.length > 1) { // Ensure there are points to connect
                    p1 = dynamicPath[dynamicPath.length - 1];
                    p2 = dynamicPath[0];
                    segmentStartDist = distances[dynamicPath.length - 1];
                    segmentEndDist = totalLength + Math.sqrt(Math.pow(dynamicPath[0].x - dynamicPath[dynamicPath.length - 1].x, 2) + Math.pow(dynamicPath[0].y - dynamicPath[dynamicPath.length - 1].y, 2)); // Add wrap-around distance
                }


                if (p1 && p2) {
                    const segmentLength = segmentEndDist - segmentStartDist;
                    const tInSegment = (targetDist - segmentStartDist) / segmentLength;

                    const x = p1.x + (p2.x - p1.x) * tInSegment;
                    const y = p1.y + (p2.y - p1.y) * tInSegment;

                    ctx.beginPath();
                    ctx.arc(x, y, ELECTRON_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.shadowBlur = 0; // Reset shadow for other drawings
        }

        // --- Main Render Loop (2D) ---
        function renderCircuit(timestamp) {
            animationTime = timestamp / 1000;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawWires();

            // Draw all components
            components.forEach(comp => {
                if (comp.type === 'resistor') {
                    drawComponent(comp, drawResistor);
                } else if (comp.type === 'capacitor') {
                    drawComponent(comp, drawCapacitor);
                } else if (comp.type === 'source') {
                    drawComponent(comp, drawSource);
                } else if (comp.type === 'inductor') {
                    drawComponent(comp, drawInductor);
                } else if (comp.type === 'ic') {
                    drawComponent(comp, drawICChip);
                }
            });

            drawElectrons();

            requestAnimationFrame(renderCircuit);
        }

        // --- Interaction Logic (2D) ---
        let dragComp = null;
        let offset = { x: 0, y: 0 };

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function isPointInComponent(x, y, comp) {
            const hitPadding = 20;
            return x >= comp.x - comp.width / 2 - hitPadding &&
                x <= comp.x + comp.width / 2 + comp.width + hitPadding && // Adjusted width check
                y >= comp.y - comp.height / 2 - hitPadding &&
                y <= comp.y + comp.height / 2 + hitPadding;
        }

        function handleDown(pos) {
            for (let i = components.length - 1; i >= 0; i--) {
                const comp = components[i];
                if (isPointInComponent(pos.x, pos.y, comp)) {
                    dragComp = comp;
                    offset.x = pos.x - comp.x;
                    offset.y = pos.y - comp.y;
                    canvas.style.cursor = 'grabbing';
                    return;
                }
            }
        }

        function handleMove(pos) {
            if (dragComp) {
                // Move the component
                dragComp.x = pos.x - offset.x;
                dragComp.y = pos.y - offset.y;
                // Clamp position to canvas bounds
                dragComp.x = Math.max(50, Math.min(canvas.width - 50, dragComp.x));
                dragComp.y = Math.max(50, Math.min(canvas.height - 50, dragComp.y));
            } else {
                // Change cursor if hovering over a draggable component
                let found = false;
                for (const comp of components) {
                    if (isPointInComponent(pos.x, pos.y, comp)) {
                        canvas.style.cursor = 'grab';
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    canvas.style.cursor = 'default';
                }
            }
        }

        function handleUp() {
            dragComp = null;
            canvas.style.cursor = 'default';
        }

        // Mouse Listeners
        canvas.addEventListener('mousedown', (e) => handleDown(getMousePos(e)));
        window.addEventListener('mousemove', (e) => handleMove(getMousePos(e)));
        window.addEventListener('mouseup', handleUp);

        // Touch Listeners (for mobile/touch devices)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleDown(getMousePos(e));
        }, { passive: false });
        window.addEventListener('touchmove', (e) => {
            e.preventDefault();
            handleMove(getMousePos(e));
        }, { passive: false });
        window.addEventListener('touchend', handleUp);

        // --- Palette Logic (Drag and Drop Mockup) ---
        const palette = document.getElementById('component-palette');
        palette.addEventListener('click', (e) => {
            const target = e.target.closest('.palette-item');
            if (!target || target.classList.contains('disabled')) return;

            const type = target.getAttribute('data-type');
            if (type === 'ic') return; // IC is disabled

            const newId = type.substring(0, 1).toUpperCase() + componentCounter++;
            let newComp;

            // Default properties for a new component, placed near the center
            const defaultX = canvas.width / 2;
            const defaultY = canvas.height / 2;

            if (type === 'resistor') {
                newComp = { id: newId, type, x: defaultX, y: defaultY, width: 80, height: 20, isDragging: false, color: '#FFFFFF' };
            } else if (type === 'capacitor') {
                newComp = { id: newId, type, x: defaultX, y: defaultY, width: 60, height: 30, isDragging: false, charge: 0, color: '#FFFFFF' };
            } else if (type === 'source') {
                newComp = { id: newId, type, x: defaultX, y: defaultY, width: 40, height: 40, isDragging: false, charge: 1, color: 'source-red' };
            } else if (type === 'inductor') {
                newComp = { id: newId, type, x: defaultX, y: defaultY, width: 80, height: 20, isDragging: false, charge: 0, color: '#FFFFFF' };
            }

            // Add the new component near the center and initiate dragging
            if (newComp) {
                components.push(newComp);
                dragComp = newComp;
                offset.x = 0; // Center the offset on spawn
                offset.y = 0;
                canvas.style.cursor = 'grabbing';
            }
        });


        // ====================================================================
        // NEW ANIMATION: High-Performance Processor (replaces Architecture Diagram)
        // ====================================================================
        const archCanvas = document.getElementById('architectureCanvas');
        const archCtx = archCanvas.getContext('2d');

        const colors = tailwind.config.theme.extend.colors; // Access tailwind colors

        // --- Processor Animation Config ---
        const PROCESSOR = {
            centerX: 0, // Will be set on resize
            centerY: 0, // Will be set on resize
            size: 150, // Base size, scales with canvas
            color: '#2A2A2A', // Dark gray body
            glowColor: colors['accent-glow'], // Neon green glow
            borderColor: '#00FF7F', // Neon green border
            traceColor: '#007F40', // Darker green for internal traces
            pinCount: 10, // Number of pins on each side
            pinLength: 30,
            pinWidth: 4,
            topGridColor: 'rgba(0, 255, 127, 0.2)', // Lighter green for top grid
        };

        const BINARY_PARTICLE = {
            count: 200,
            speed: 1.5,
            radius: 2,
            colors: ['#00FFFF', '#00FF7F'], // Cyan and Neon Green
            font: '14px Arial',
            binaryChars: ['0', '1'],
            flowRadius: 200, // How far binary numbers originate from center
            flowSpeed: 0.8,
            flowOffset: 50, // How far above the processor they start
            gridTrailColor: 'rgba(0, 255, 127, 0.1)', // Light green faint trails
        };

        let binaryParticles = []; // Array to hold binary characters/particles
        let processorAnimationTime = 0;

        function resizeArchCanvas() {
            // Keep a fixed width/height ratio (approx 800x400)
            const aspectRatio = 800 / 400;
            const parentWidth = archCanvas.parentElement.clientWidth;

            archCanvas.width = Math.min(parentWidth, 800);
            archCanvas.height = archCanvas.width / aspectRatio;

            // Adjust processor and particle properties based on new size
            PROCESSOR.centerX = archCanvas.width / 2;
            PROCESSOR.centerY = archCanvas.height / 2;
            PROCESSOR.size = archCanvas.width * 0.18; // Scale processor size
            PROCESSOR.pinLength = archCanvas.width * 0.04;
            PROCESSOR.pinWidth = Math.max(1, archCanvas.width * 0.005);

            BINARY_PARTICLE.flowRadius = archCanvas.width * 0.3;
            BINARY_PARTICLE.flowOffset = archCanvas.height * 0.1;
            BINARY_PARTICLE.speed = archCanvas.height * 0.004;
            BINARY_PARTICLE.radius = Math.max(1, archCanvas.width * 0.003);
            BINARY_PARTICLE.font = `${Math.max(10, archCanvas.width * 0.015)}px monospace`;

            // Re-initialize particles to adapt to new canvas size
            initializeProcessorParticles();
        }

        // Initialize particles for the new processor animation
        function initializeProcessorParticles() {
            binaryParticles = [];
            for (let i = 0; i < BINARY_PARTICLE.count; i++) {
                binaryParticles.push({
                    x: PROCESSOR.centerX + (Math.random() - 0.5) * BINARY_PARTICLE.flowRadius * 2,
                    y: PROCESSOR.centerY - BINARY_PARTICLE.flowOffset - Math.random() * archCanvas.height / 2, // Start high
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: Math.random() * BINARY_PARTICLE.speed * 0.5 + BINARY_PARTICLE.speed * 0.5,
                    char: BINARY_PARTICLE.binaryChars[Math.floor(Math.random() * 2)],
                    color: BINARY_PARTICLE.colors[Math.floor(Math.random() * BINARY_PARTICLE.colors.length)],
                    opacity: 1,
                    size: Math.random() * 0.5 + 0.5, // Scale character size
                    targetX: PROCESSOR.centerX + (Math.random() - 0.5) * PROCESSOR.size * 0.8,
                    targetY: PROCESSOR.centerY + (Math.random() - 0.5) * PROCESSOR.size * 0.8,
                    phase: Math.random() * Math.PI * 2 // For oscillating movement
                });
            }
        }

        function drawProcessor() {
            const size = PROCESSOR.size;
            const centerX = PROCESSOR.centerX;
            const centerY = PROCESSOR.centerY;

            // Base processor body
            archCtx.fillStyle = PROCESSOR.color;
            archCtx.fillRect(centerX - size / 2, centerY - size / 2, size, size);

            // Inner grid pattern (similar to image)
            archCtx.strokeStyle = PROCESSOR.topGridColor;
            archCtx.lineWidth = 1;
            const gridSize = 10;
            for (let i = 0; i < size; i += gridSize) {
                archCtx.beginPath();
                archCtx.moveTo(centerX - size / 2 + i, centerY - size / 2);
                archCtx.lineTo(centerX - size / 2 + i, centerY + size / 2);
                archCtx.moveTo(centerX - size / 2, centerY - size / 2 + i);
                archCtx.lineTo(centerX + size / 2, centerY - size / 2 + i);
                archCtx.stroke();
            }


            // Glow effect for the top surface and edges
            archCtx.shadowColor = PROCESSOR.glowColor;
            archCtx.shadowBlur = 25 * (0.8 + Math.sin(processorAnimationTime * 0.05) * 0.2); // Pulsing glow
            archCtx.strokeStyle = PROCESSOR.borderColor;
            archCtx.lineWidth = 3;
            archCtx.strokeRect(centerX - size / 2, centerY - size / 2, size, size);
            archCtx.shadowBlur = 0; // Reset shadow


            // Draw "pins" / data lines coming out from the sides
            archCtx.strokeStyle = PROCESSOR.glowColor;
            archCtx.lineWidth = PROCESSOR.pinWidth;

            const pinOffset = size / PROCESSOR.pinCount;

            for (let i = 0; i < PROCESSOR.pinCount; i++) {
                const yPos = centerY - size / 2 + i * pinOffset + pinOffset / 2;
                const xPosLeft = centerX - size / 2;
                const xPosRight = centerX + size / 2;

                // Left pins
                archCtx.beginPath();
                archCtx.moveTo(xPosLeft, yPos);
                archCtx.lineTo(xPosLeft - PROCESSOR.pinLength, yPos);
                archCtx.stroke();

                // Right pins
                archCtx.beginPath();
                archCtx.moveTo(xPosRight, yPos);
                archCtx.lineTo(xPosRight + PROCESSOR.pinLength, yPos);
                archCtx.stroke();
            }

            // Central light source effect
            const lightGlow = 40 * (0.8 + Math.sin(processorAnimationTime * 0.05) * 0.2);
            const gradient = archCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size * 0.4);
            gradient.addColorStop(0, `rgba(0, 255, 127, ${lightGlow / 100})`); // Center is brighter
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            archCtx.fillStyle = gradient;
            archCtx.fillRect(centerX - size / 2, centerY - size / 2, size, size);
        }

        function drawBinaryParticles() {
            archCtx.font = BINARY_PARTICLE.font;
            archCtx.textAlign = 'center';
            archCtx.textBaseline = 'middle';

            binaryParticles.forEach(p => {
                // Animate particles flowing down and converging towards the center
                p.x += p.vx * BINARY_PARTICLE.flowSpeed + Math.sin(processorAnimationTime * 0.1 + p.phase) * 0.5;
                p.y += p.vy * BINARY_PARTICLE.flowSpeed;

                // Simple attraction towards the center to create funnel effect
                const dx = PROCESSOR.centerX - p.x;
                const dy = (PROCESSOR.centerY - BINARY_PARTICLE.flowOffset) - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < BINARY_PARTICLE.flowRadius) { // Start converging closer to processor
                    p.x += dx * 0.01; // Gentle pull towards center X
                    p.y += dy * 0.01; // Gentle pull towards center Y (above processor)
                }

                // Fade out as they get close to the processor
                const fadeDistance = PROCESSOR.size * 0.7;
                const distanceToProcessorCenter = Math.sqrt(
                    Math.pow(p.x - PROCESSOR.centerX, 2) + Math.pow(p.y - PROCESSOR.centerY, 2)
                );

                if (distanceToProcessorCenter < fadeDistance) {
                    p.opacity = Math.max(0, (distanceToProcessorCenter - (PROCESSOR.size / 2)) / (fadeDistance - (PROCESSOR.size / 2)));
                    if (p.opacity < 0.1) {
                        // Reset particle once it "enters" the processor
                        p.x = PROCESSOR.centerX + (Math.random() - 0.5) * BINARY_PARTICLE.flowRadius * 2;
                        p.y = PROCESSOR.centerY - BINARY_PARTICLE.flowOffset - Math.random() * archCanvas.height / 2;
                        p.vx = (Math.random() - 0.5) * 0.5;
                        p.vy = Math.random() * BINARY_PARTICLE.speed * 0.5 + BINARY_PARTICLE.speed * 0.5;
                        p.char = BINARY_PARTICLE.binaryChars[Math.floor(Math.random() * 2)];
                        p.color = BINARY_PARTICLE.colors[Math.floor(Math.random() * BINARY_PARTICLE.colors.length)];
                        p.opacity = 1;
                        p.size = Math.random() * 0.5 + 0.5;
                        p.phase = Math.random() * Math.PI * 2;
                    }
                } else {
                    p.opacity = 1;
                }

                archCtx.fillStyle = p.color;
                archCtx.globalAlpha = p.opacity;
                archCtx.shadowColor = p.color;
                archCtx.shadowBlur = 8;
                archCtx.fillText(p.char, p.x, p.y);
                archCtx.globalAlpha = 1; // Reset alpha
            });
            archCtx.shadowBlur = 0; // Reset shadow
        }

        function renderArchitecture(timestamp) {
            processorAnimationTime = timestamp / 1000;
            archCtx.clearRect(0, 0, archCanvas.width, archCanvas.height);

            // Draw a dark background
            archCtx.fillStyle = '#000000';
            archCtx.fillRect(0, 0, archCanvas.width, archCanvas.height);

            // Draw background grid/trails (faint)
            archCtx.strokeStyle = BINARY_PARTICLE.gridTrailColor;
            archCtx.lineWidth = 1;
            const tileRes = archCanvas.width / 20; // Example resolution for tiles
            for (let i = 0; i < archCanvas.width; i += tileRes) {
                for (let j = 0; j < archCanvas.height; j += tileRes) {
                    if (Math.random() < 0.1) { // Randomly draw faint squares
                        const rectSize = tileRes * (0.2 + Math.random() * 0.6);
                        archCtx.globalAlpha = 0.05 + Math.random() * 0.05;
                        archCtx.strokeRect(i + (tileRes - rectSize) / 2, j + (tileRes - rectSize) / 2, rectSize, rectSize);
                        archCtx.globalAlpha = 1;
                    }
                }
            }


            drawBinaryParticles(); // Draw the flowing binary numbers
            drawProcessor();       // Draw the central processor

            requestAnimationFrame(renderArchitecture);
        }

        // --- Global Initialization ---
        window.onload = function () {
            // Circuit Simulation Init
            resizeCircuitCanvas();
            renderCircuit(0);

            // Processor Animation Init
            resizeArchCanvas();
            initializeProcessorParticles();
            renderArchitecture(0);
        }

        // Handle resize event for the new animation
        window.addEventListener('resize', resizeArchCanvas);
    </script>
</body>
</html>
