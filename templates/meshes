<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meshes & Rigging Portfolio</title>
    
    <!-- Google Fonts --><link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght[300;400;700@display=swap" rel="stylesheet">
    
    <!-- Font Awesome --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'cyber-black': '#0f172a',
                        'cyber-blue': '#38bdf8',
                        'cyber-purple': '#818cf8',
                        'light-wireframe': '#e0e0e0', // Defined the requested light gray/wireframe color
                    },
                    fontFamily: {
                        'display': ['Orbitron', 'sans-serif'],
                        'body': ['Roboto', 'sans-serif'],
                    },
                    boxShadow: {
                        'glow-blue': '0 0 20px rgba(56, 189, 248, 0.5), 0 0 40px rgba(56, 189, 248, 0.3)',
                    },
                    keyframes: {
                        spin3D: {
                            '0%, 100%': { transform: 'rotateY(0deg) scale(1)' },
                            '50%': { transform: 'rotateY(180deg) scale(1.05)' },
                        },
                        borderSpin: {
                            '0%': { backgroundPosition: '0% 50%' },
                            '50%': { backgroundPosition: '100% 50%' },
                            '100%': { backgroundPosition: '0% 50%' },
                        },
                    },
                    animation: {
                        spin3D: 'spin3D 4s ease-in-out infinite alternate',
                        borderSpin: 'borderSpin 4s linear infinite', 
                    }
                }
            }
        }
    </script>

    <!-- 3D Libraries --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #0f172a; 
        }
        ::-webkit-scrollbar-thumb {
            background: #38bdf8; 
            border-radius: 4px;
        }

        /* Diagonal Path Keyframes: Top-Left -> Center -> Bottom-Right */
        @keyframes slideDiagonalCenter {
            0% {
                opacity: 0;
                transform: translate(-80vw, -60vh) rotate(-45deg) scale(0.5);
            }
            15% {
                opacity: 1;
            }
            40% {
                transform: translate(-50%, -50%) rotate(-10deg) scale(1);
            }
            60% {
                transform: translate(-50%, -50%) rotate(10deg) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(80vw, 60vh) rotate(45deg) scale(0.5);
            }
        }

        .animate-slide-path {
            animation: slideDiagonalCenter 10s linear infinite;
        }

        /* Pause animation on hover */
        .hover-pause:hover {
            animation-play-state: paused;
            z-index: 50; 
            cursor: pointer;
            filter: drop-shadow(0 0 25px rgba(56, 189, 248, 1)); 
        }
        
        /* Stop internal 3D spin on hover */
        .hover-pause:hover .animate-spin-on-path {
            animation-play-state: paused;
            transform: scale(1.1) !important; 
        }

        /* Glassmorphism utility */
        .glass-panel {
            background: rgba(15, 23, 42, 0.75);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(56, 189, 248, 0.2);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }

        html {
            scroll-behavior: smooth;
        }

        /* Hero Section Background (Abstract, light gray wireframe network - CORRECTLY STAYS ON HERO) */
        #home {
            background-image: none;
            background-color: #1a233a; /* Slightly less black background */
            /* Complex abstract wireframe network pattern using light gray */
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(220, 220, 220, 0.05) 1px, transparent 1px),
                linear-gradient(135deg, rgba(220, 220, 220, 0.05) 1px, transparent 1px),
                linear-gradient(45deg, rgba(220, 220, 220, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
        }
        #home::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Radial fade to focus on the center content/3D model */
            background: radial-gradient(circle at center, rgba(26, 35, 58, 0) 0%, rgba(26, 35, 58, 0.8) 75%);
            pointer-events: none;
            z-index: 1; 
        }
        
        /* Header Styling (UPDATED: Removed background-image/grid from NAV) */
        .header-wireframe {
            background-color: rgba(15, 23, 42, 0.9); /* Base black/dark blue */
            background-image: none; /* <--- REMOVED GRID PATTERN HERE */
            background-size: initial;
            backdrop-filter: blur(8px);
            border-bottom: 1px solid rgba(56, 189, 248, 0.2);
        }

        /* Hero Text Styling (NEW: Silver/Light/Transparent Effect) */
        #home h1 {
            /* Simulates a silver/light metallic glow/transparency */
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.6), 0 0 15px rgba(192, 192, 192, 0.4);
            filter: brightness(1.2); 
            /* Text opacity is handled by the subtle nature of the glow + clip-text */
        }
        #home p {
            /* Subtle white text shadow for a light effect and slight transparency */
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.2);
            opacity: 0.95; 
        }

        /* Spinning Border Effect Setup */
        .image-wrapper {
            position: relative;
            display: inline-block; 
            overflow: hidden; 
            border-radius: 0.5rem; 
        }

        /* Glowing Spinning Border using a Pseudo-element */
        .image-wrapper::before {
            content: '';
            position: absolute;
            inset: -4px; 
            border-radius: inherit; 
            background: conic-gradient(from 0deg, transparent 0%, #38bdf8 20%, #818cf8 40%, transparent 100%);
            background-size: 200% 200%; 
            animation: borderSpin 4s linear infinite; 
            z-index: -1; 
            opacity: 0; 
            transition: opacity 0.3s ease;
        }

        /* Only apply glow on hover to images in the main content section */
        #image-vs-mesh .image-wrapper:hover::before {
            opacity: 1; 
        }

        /* Ensure images inside cards scale nicely */
        #image-vs-mesh img {
            max-height: 200px;
        }
    </style>
</head>
<body class="bg-cyber-black text-gray-100 font-body overflow-x-hidden relative min-h-screen selection:bg-cyber-blue selection:text-cyber-black">

    <!-- Three.js Background Canvas (Wireframe Human Model) - Z-index updated to -z-30 to ensure it's in the deep background and the opacity is increased --><canvas id="bg-canvas" class="fixed top-0 left-0 w-full h-full -z-30 opacity-95"></canvas>

    <!-- Header / Navigation Bar -->
     <header class="fixed w-full top-0 z-50 header-wireframe">
        <nav class="container mx-auto px-6 py-4">
            <div class="flex justify-between items-center">
                <div class="text-2xl font-display font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyber-blue to-cyber-purple">
                    <i class="fa-solid fa-cube mr-2"></i>DigitalTwin
                </div>
                <ul class="hidden md:flex space-x-8 font-bold">
                    <li><a href="#home" class="hover:text-cyber-blue transition-colors"><i class="fa-solid fa-house mr-1"></i> Home</a></li>
                    <li><a href="#meshes" class="hover:text-cyber-blue transition-colors"><i class="fa-solid fa-draw-polygon mr-1"></i> Meshes</a></li>
                    <li><a href="#rigging" class="hover:text-cyber-blue transition-colors"><i class="fa-solid fa-bone mr-1"></i> Rigging</a></li>
                    <li><a href="#animations" class="hover:text-cyber-blue transition-colors"><i class="fa-solid fa-person-running mr-1"></i> Animations</a></li>
                    <li><a href="#blender" class="hover:text-cyber-blue transition-colors"><i class="fa-brands fa-unity mr-1"></i> Blender</a></li>
                </ul>
                <!-- Mobile Menu Button -->
                 <button class="md:hidden text-2xl text-cyber-blue">
                    <i class="fa-solid fa-bars"></i>
                </button>
            </div>
        </nav>
    </header>

    <!-- Hero Section (Home) -->
     <section id="home" class="relative pt-32 pb-20 min-h-[80vh] flex flex-col items-center justify-center overflow-hidden">
        
        <!-- Animated Image Slider Container (Z-index 10) -->
         <div id="slider-container" class="absolute inset-0 pointer-events-none z-10">
            <!-- Images are injected here by JavaScript -->
        </div>

        <div class="text-center z-20 px-4 pointer-events-none">
            
            <!-- Main Title (UPDATED: Specific Silver Gradient #C8C8C8) -->
             <h1 class="text-5xl md:text-3xl font-display font-bold mb-6 bg-clip-text text-transparent pointer-events-auto" style="background-image: linear-gradient(to right, #a79494, hsl(175, 67%, 82%), #c9e5ee);">
                Vector Rigging Model
            </h1>
            <!-- Subtitle (Shadow removed, effect moved to CSS) -->
             <p class="text-xl md:text-lg text-gray-500 max-w-2xl mx-auto mb-8 pointer-events-auto">
                Observe procedurally generated human wireframe and learn the fundamentals of mesh binding.
            </p>
            <a href="#rigging" class="pointer-events-auto inline-block px-8 py-3 rounded-full bg-gradient-to-r from-cyber-blue to-blue-600 text-white font-bold shadow-lg hover:shadow-cyber-blue/50 transition transform hover:-translate-y-1">
                Explore Rigging
            </a>
        </div>
    </section>

    <!-- Main Content -->
     <main class="container mx-auto px-4 pb-20 relative z-10">
        
        <!-- Main Content Panel (Glassmorphism) -->
         <div class="glass-panel rounded-3xl p-8 md:p-12 shadow-2xl border-t border-cyber-blue/20 relative overflow-hidden group">
            
            <!-- Decorative Top Border -->
             <div class="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-transparent via-cyber-blue to-transparent opacity-50"></div>

            <section id="meshes" class="mb-16">
                <div class="flex items-center mb-6">
                    <div class="w-12 h-12 rounded-full bg-cyber-blue/20 flex items-center justify-center mr-4 text-cyber-blue">
                        <i class="fa-solid fa-vector-square text-2xl"></i>
                    </div>
                    <h2 class="text-3xl font-display font-bold text-white">Understanding Meshes</h2>
                </div>
                <div class="grid md:grid-cols-2 gap-8">
                    <div class="prose prose-invert max-w-none">
                        <p class="text-lg text-gray-300 leading-relaxed">
                            A mesh is a collection of vertices, edges, and faces that defines the shape of a 3D object in computer graphics. It is the fundamental building block for creating 3D models. 
                            Without proper topology, lighting and deformation will fail during rendering.
                        </p>
                    </div>
                    <div class="bg-black/30 rounded-xl p-6 border border-white/5 hover:border-cyber-blue/30 transition-colors">
                        <h3 class="text-xl font-bold text-cyber-blue mb-4">Key Components</h3>
                        <ul class="space-y-3">
                            <li class="flex items-center"><i class="fa-solid fa-circle-dot text-xs mr-3 text-pink-500"></i> Vertices (Points in 3D space)</li>
                            <li class="flex items-center"><i class="fa-solid fa-minus text-xs mr-3 text-pink-500"></i> Edges (Lines connecting vertices)</li>
                            <li class="flex items-center"><i class="fa-solid fa-square text-xs mr-3 text-pink-500"></i> Faces (Polygons formed by edges)</li>
                        </ul>
                    </div>
                </div>
            </section>

            <hr class="border-gray-700 my-12">

            <section id="types">
                <div class="flex items-center mb-6">
                    <div class="w-12 h-12 rounded-full bg-purple-500/20 flex items-center justify-center mr-4 text-purple-400">
                        <i class="fa-solid fa-shapes text-2xl"></i>
                    </div>
                    <h2 class="text-3xl font-display font-bold text-white">Types of Meshes</h2>
                </div>
                <div class="grid md:grid-cols-3 gap-6">
                    
                    <div class="bg-gradient-to-br from-gray-800 to-gray-900 p-6 rounded-xl hover:transform hover:-translate-y-2 transition duration-300 border-l-4 border-blue-500">
                        <h3 class="text-xl font-bold mb-2">Polygonal Meshes</h3>
                        <p class="text-sm text-gray-400">Made up of polygons, typically triangles (tris) or quads. The standard for game engines like Unity and Unreal.</p>
                    </div>
                    
                    <div class="bg-gradient-to-br from-gray-800 to-gray-900 p-6 rounded-xl hover:transform hover:-translate-y-2 transition duration-300 border-l-4 border-purple-500">
                        <h3 class="text-xl font-bold mb-2">NURBS Meshes</h3>
                        <p class="text-sm text-gray-400">Non-Uniform Rational B-Splines. Defined by mathematical curves, allowing for perfectly smooth surfaces. Used in automotive design.</p>
                    </div>
                    
                    <div class="bg-gradient-to-br from-gray-800 to-gray-900 p-6 rounded-xl hover:transform hover:-translate-y-2 transition duration-300 border-l-4 border-pink-500">
                        <h3 class="text-xl font-bold mb-2">Subdivision Surfaces</h3>
                        <p class="text-sm text-gray-400">Start with a coarse low-poly mesh and algorithmically refine it to create a high-resolution smooth surface.</p>
                    </div>
                </div>
            </section>

            <hr class="border-gray-700 my-12">

            <section id="rigging">
                <div class="flex items-center mb-6">
                    <div class="w-12 h-12 rounded-full bg-green-500/20 flex items-center justify-center mr-4 text-green-400">
                        <i class="fa-solid fa-bone text-2xl"></i>
                    </div>
                    <h2 class="text-3xl font-display font-bold text-white">Wire Binding (Skinning)</h2>
                </div>
                <p class="text-lg text-gray-300 mb-8">
                    Rigging involves creating the **skeleton** (the wireframe you see in the background) and then **binding** or **skinning** the high-resolution mesh (the character's skin) to it.
                </p>
                
                <div class="bg-black/40 rounded-xl p-8 border border-gray-700">
                    <h3 class="text-2xl font-display font-bold mb-6 text-center">How Wire Binding Works</h3>
                    <div class="grid md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="text-xl font-bold text-cyber-blue mb-2">1. Vertex Weighting</h4>
                            <p class="text-gray-400 text-sm">Every single vertex (point) on the character's mesh is assigned a **weight value** for each bone. A weight of 1.0 means the vertex is fully controlled by that bone (e.g., a hand vertex to the hand bone). A weight of 0.5 means it's equally influenced by two bones (e.g., vertices near the elbow or knee joint). </p>
                        </div>
                        <div>
                            <h4 class="text-xl font-bold text-cyber-blue mb-2">2. Deformation</h4>
                            <p class="text-gray-400 text-sm">When a bone (like the animated shoulder bone in the background figure) rotates, the position of every bound vertex is recalculated based on its assigned weights. This allows the mesh to deform naturally with the skeleton, crucial for smooth skin around joints.</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Separator for the new section -->
            <hr class="border-gray-700 my-12">

            <!-- UPDATED SECTION: Image vs 3D Meshes -->
            <section id="image-vs-mesh" class="mb-16">
                <!-- Main Heading -->
                <div class="flex items-center mb-6">
                    <div class="w-12 h-12 rounded-full bg-yellow-500/20 flex items-center justify-center mr-4 text-yellow-400">
                        <i class="fa-solid fa-layer-group text-2xl"></i>
                    </div>
                    <h2 class="text-3xl font-display font-bold text-white">Image vs 3D Meshes</h2>
                </div>
                
                <h3 class="text-2xl font-display font-bold text-gray-300 mb-6 border-b border-gray-700 pb-2">Extension: Dimensional Breakdown</h3>

                <!-- Content grid for comparison -->
                <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
                    
                    <!-- 2D Image Card (UPDATED with image and detailed X/Y/Color info) -->
                    <div class="bg-gray-800/50 p-6 rounded-xl border border-red-500/40 shadow-xl transition-all hover:border-red-400">
                        <h3 class="text-xl font-bold text-red-400 mb-3"><i class="fa-solid fa-image mr-2"></i> Image (2D) - Flat Grid</h3>
                        <p class="text-sm text-gray-300 leading-relaxed mb-3">
                            A 2D picture is a flat plane of information made of discrete units called **pixels**. Each pixel is precisely located using an **X, Y pointer** (coordinate) and stores only a **color value** (e.g., RGBA).
                        </p>
                        
                        <!-- IMAGE INJECTION: 2D Image Example -->
                        <div class="image-wrapper w-full h-auto mt-4 mb-3">
                            <img src="https://us1.discourse-cdn.com/flex024/uploads/babylonjs/original/3X/b/7/b7b6f8cc4c55a8698fc9bcbf6f1384c20db3cf74.png" 
                                 onerror="this.onerror=null;this.src='https://placehold.co/400x200/550000/FFFFFF?text=2D+Image+Error:+Check+URL';"
                                 class="w-full h-auto object-contain rounded-lg shadow-md border border-red-500/50">
                        </div>

                        <p class="text-xs italic text-gray-400 border-t border-gray-700 pt-2">
                            <strong>DOM/CSS Interaction:</strong> On a webpage, the DOM handles image placement. CSS controls movement (translate X, Y) and layering (`z-index`), but this is simulated depth only.
                        </p>
                    </div>

                    <!-- 3D Mesh Card (UPDATED with image and detailed X/Y/Z info) -->
                    <div class="bg-gray-800/50 p-6 rounded-xl border border-cyber-blue/40 shadow-xl transition-all hover:border-cyber-blue">
                        <h3 class="text-xl font-bold text-cyber-blue mb-3"><i class="fa-solid fa-cube mr-2"></i> 3D Mesh (3D) - True Volume</h3>
                        <p class="text-sm text-gray-300 leading-relaxed mb-3">
                            A real 3D shape built on vertices, edges, and faces existing in **X, Y, Z space**. This crucial **Z-axis extension** gives the object real depth, volume, and allows for complex interactions like physics and lighting occlusion.
                        </p>
                        
                        <!-- IMAGE INJECTION: 3D Mesh Example -->
                        <div class="image-wrapper w-full h-auto mt-4 mb-3">
                            <img src="https://canada1.discourse-cdn.com/flex035/uploads/threejs/original/3X/9/2/9219be3c6910cefc826a5c94ef92b78a6aa89e02.png" 
                                 onerror="this.onerror=null;this.src='https://placehold.co/400x200/003366/FFFFFF?text=3D+Mesh+Error:+Check+URL';"
                                 class="w-full h-auto object-contain rounded-lg shadow-md border border-cyber-blue/50">
                        </div>

                        <p class="text-xs italic text-gray-400 border-t border-gray-700 pt-2">
                            <strong>3D Engine Extension:</strong> Engines like Three.js continually calculate the object's position, rotation, and lighting for every vertex in the true 3D space, updating the perspective as the camera moves.
                        </p>
                    </div>

                    <!-- Texture/UV Map Card -->
                    <div class="bg-gray-800/50 p-6 rounded-xl border border-green-500/40 shadow-xl transition-all hover:border-green-400">
                        <h3 class="text-xl font-bold text-green-400 mb-3"><i class="fa-solid fa-map-pin mr-2"></i> Texture & UV Map</h3>
                        <ul class="text-sm text-gray-300 space-y-2 list-none p-0">
                            <li class="pl-0"><strong class="text-yellow-300">Texture:</strong> A normal 2D image wrapped on the mesh surface to give it color, detail, and style.</li>
                            <li class="pl-0"><strong class="text-yellow-300">UV Map:</strong> A layout that tells which part of the 2D image should stick to which part of the 3D model.</li>
                        </ul>
                    </div>
                    
                </div>
            </section>
            
        </div>
    </main>

    <!-- Footer --><footer class="glass-panel mt-12 border-t border-gray-800">
        <div class="container mx-auto px-6 py-8">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div class="mb-4 md:mb-0">
                    <span class="text-xl font-display font-bold text-white">Digital Twin</span>
                    <p class="text-gray-500 text-sm">Â© 2024 Digital Twin Tutorials. All rights reserved.</p>
                </div>
                <div class="flex space-x-6">
                    <a href="#" class="text-gray-400 hover:text-white transition"><i class="fa-brands fa-github text-xl"></i></a>
                    <a href="#" class="text-gray-400 hover:text-white transition"><i class="fa-brands fa-twitter text-xl"></i></a>
                    <a href="#" class="text-gray-400 hover:text-white transition"><i class="fa-brands fa-linkedin text-xl"></i></a>
                </div>
            </div>
        </div>
    </footer>

    <!-- Javascript Logic --><script>
        // 1. Slider Logic (Diagonal Drop)
        const sliderImages = [
            'https://github.com/Afsana721/PortfolioProjects/blob/main/mesh1.png?raw=true',
            'https://github.com/Afsana721/PortfolioProjects/blob/main/mesh2.png?raw=true',
            'https://github.com/Afsana721/PortfolioProjects/blob/main/mesh4.png?raw=true',
            'https://github.com/Afsana721/PortfolioProjects/blob/main/mesh3.png?raw=true',
            'https://github.com/Afsana721/PortfolioProjects/blob/main/mesh1.png?raw=true',
            'https://github.com/Afsana721/PortfolioProjects/blob/main/mesh2.png?raw=true',
            'https://github.Afsana721/PortfolioProjects/blob/main/mesh4.png?raw=true',
            'https://github.com/Afsana721/PortfolioProjects/blob/main/mesh3.png?raw=true',
        ];

        const container = document.getElementById('slider-container');

        function spawnFloatingImage(index) {
            const imgWrapper = document.createElement('div');
            // Removed specific animation classes from here to prevent conflict with static images below
            imgWrapper.className = 'image-wrapper absolute w-64 h-64 animate-slide-path hover-pause pointer-events-auto';
            imgWrapper.style.animationDelay = `${Math.random() * 2}s`; 

            const img = document.createElement('img');
            img.src = sliderImages[index % sliderImages.length];
            img.className = 'w-full h-full object-cover rounded-lg shadow-glow-blue animate-spin-on-path'; 
            
            imgWrapper.appendChild(img);
            container.appendChild(imgWrapper);

            imgWrapper.style.left = '50%';
            imgWrapper.style.top = '50%';
            
            setTimeout(() => {
                if(!imgWrapper.matches(':hover')) {
                    imgWrapper.remove();
                } else {
                    setTimeout(() => imgWrapper.remove(), 5000); 
                }
            }, 10000); 
        }

        let imgIndex = 0;
        setInterval(() => {
            spawnFloatingImage(imgIndex);
            imgIndex++;
        }, 3000);
        
        spawnFloatingImage(0);


        // 2. Three.js Wireframe Human Rig Setup
        const canvas = document.querySelector('#bg-canvas');
        const scene = new THREE.Scene();
        // Camera position adjusted to be slightly closer (z=12 instead of 15)
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        camera.position.z = 12; // Closer camera position
        camera.position.y = 3; 

        // Wireframe Material Definition (Color changed to light gray/white for wireframe)
        const rigMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xe0e0e0, // Light Gray/White
            wireframe: true,
            transparent: true,
            opacity: 0.8, // Slightly more subtle
            side: THREE.DoubleSide
        });

        // Bone/Limb Geometry
        const boneRadius = 0.1;
        const jointRadius = 0.3;
        const headRadius = 1.0;
        // Use different geometries for variation
        const jointGeometry = new THREE.TorusGeometry(jointRadius, 0.1, 4, 8); // Torus for joints
        const headGeometry = new THREE.DodecahedronGeometry(headRadius, 0); // Dodecahedron for head
        const limbGeometry = new THREE.IcosahedronGeometry(boneRadius, 1); // Abstract shapes for limbs

        // Helper functions
        function createLimb(height) {
            // Using a Group and Meshes along a line to form an abstract "limb"
            const group = new THREE.Group();
            
            const count = Math.ceil(height / 0.5); // Number of segments
            const segmentStep = height / count;

            for (let i = 0; i <= count; i++) {
                // Creating interconnected, non-straight elements
                const mesh = new THREE.Mesh(limbGeometry, rigMaterial);
                mesh.scale.set(1, 1, 1);
                mesh.position.y = (i * segmentStep) - (height / 2);
                
                // Add slight random rotation for non-straight appearance
                mesh.rotation.x = Math.random() * Math.PI;
                mesh.rotation.y = Math.random() * Math.PI;

                group.add(mesh);
            }
            // Add a line between segments for connection
            const points = [];
            for (let i = 0; i <= count; i++) {
                points.push(new THREE.Vector3(0, (i * segmentStep) - (height / 2), 0));
            }
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({ color: 0xe0e0e0, opacity: 0.5, transparent: true }));
            group.add(line);

            return group;
        }

        function createJoint(geometry = jointGeometry) {
            return new THREE.Mesh(geometry, rigMaterial);
        }

        // --- Figure Construction ---
        const figureGroup = new THREE.Group();
        figureGroup.rotation.y = Math.PI / 4; // Start slightly angled

        // 1. Torso/Spine (Root)
        const torsoHeight = 4;
        const torso = createLimb(torsoHeight);
        torso.position.y = torsoHeight / 2;
        figureGroup.add(torso);

        // 2. Head
        const headJoint = createJoint(headGeometry);
        headJoint.position.y = torsoHeight + headRadius;
        figureGroup.add(headJoint);

        // 3. Right Arm (Static)
        const rightShoulderJoint = createJoint();
        rightShoulderJoint.position.set(1.5, torsoHeight - 0.5, 0);
        figureGroup.add(rightShoulderJoint);

        const rightUpperArm = createLimb(2);
        rightUpperArm.rotation.set(0, 0, -Math.PI / 2); // Set rotation
        rightUpperArm.position.set(1, 0, 0); // Position the arm segments relative to shoulder
        rightShoulderJoint.add(rightUpperArm);

        const rightElbowJoint = createJoint();
        rightElbowJoint.position.set(2, 0, 0);
        rightUpperArm.add(rightElbowJoint);

        // 4. Left Arm (Animated Rig Demonstration)
        const leftShoulderJoint = createJoint();
        leftShoulderJoint.position.set(-1.5, torsoHeight - 0.5, 0);
        figureGroup.add(leftShoulderJoint); 

        const leftUpperArm = createLimb(2);
        leftUpperArm.rotation.set(0, 0, Math.PI / 2); // Set rotation
        leftUpperArm.position.set(-1, 0, 0); // Position the arm segments relative to shoulder
        leftShoulderJoint.add(leftUpperArm);
        
        const leftElbowJoint = createJoint();
        leftElbowJoint.position.set(-2, 0, 0);
        leftUpperArm.add(leftElbowJoint);
        
        const leftForeArm = createLimb(1.8);
        leftForeArm.rotation.set(0, 0, Math.PI / 2); // Set rotation
        leftForeArm.position.set(-0.9, 0, 0); // Position relative to elbow
        leftElbowJoint.add(leftForeArm);

        // 5. Hip Joint (Base of the lower body rig)
        const hipJoint = createJoint();
        hipJoint.position.y = 0;
        figureGroup.add(hipJoint);
        
        // 6. Legs (Example - using similar abstract structure)
        const legHeight = 3.5;
        
        const rightLegGroup = new THREE.Group();
        rightLegGroup.position.set(0.5, 0, 0);
        hipJoint.add(rightLegGroup);

        const rightThigh = createLimb(legHeight);
        rightThigh.position.y = -legHeight / 2;
        rightLegGroup.add(rightThigh);
        
        const leftLegGroup = new THREE.Group();
        leftLegGroup.position.set(-0.5, 0, 0);
        hipJoint.add(leftLegGroup);
        
        const leftThigh = createLimb(legHeight);
        leftThigh.position.y = -legHeight / 2;
        leftLegGroup.add(leftThigh);


        // Position the whole figure (Raised slightly to be more central)
        figureGroup.position.set(0, -4, 0); 
        scene.add(figureGroup);

        // Ambient and Directional Light
        // Using light gray/white ambient light to match the wireframe color
        const ambientLight = new THREE.AmbientLight(0xe0e0e0, 0.4); 
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);

        // Mouse Interaction for subtle camera movement
        let mouseX = 0;
        let mouseY = 0;
        
        document.addEventListener('mousemove', (event) => {
            mouseX = event.clientX / window.innerWidth - 0.5;
            mouseY = event.clientY / window.innerHeight - 0.5;
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            // 3D Model Animation (Demonstrates Rig movement)
            // 1. Arm movement (Shoulder rotation)
            leftShoulderJoint.rotation.x = Math.sin(elapsedTime * 1.5) * 0.8;
            leftShoulderJoint.rotation.y = Math.cos(elapsedTime * 0.7) * 0.5;

            // 2. Elbow movement
            leftElbowJoint.rotation.z = Math.sin(elapsedTime * 1.5) * 0.5;

            // 3. Figure breathing/floating
            // Adjusted base position to -4
            figureGroup.position.y = -4 + Math.sin(elapsedTime * 0.5) * 0.2;
            figureGroup.rotation.z = mouseX * 0.1;

            // Leg movement (subtle knee bend)
            rightLegGroup.rotation.x = Math.sin(elapsedTime * 0.7) * 0.1;
            leftLegGroup.rotation.x = Math.cos(elapsedTime * 0.7) * 0.1;

            // Camera movement based on mouse
            camera.position.x += (mouseX * 5 - camera.position.x) * 0.05;
            camera.position.y += (-mouseY * 5 - camera.position.y + 3) * 0.05;
            camera.lookAt(figureGroup.position);

            renderer.render(scene, camera);
        }

        window.onload = function () {
            animate();
        };
        

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
